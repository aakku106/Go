# Code Review: 0.0012/concurrency/goRutines.go

## Overall Assessment

**File Purpose**: Learn goroutine basics and concurrent execution  
**Rating**: 7/10  
**Status**: Good initial exploration, needs synchronization!

---

## Detailed Review

### âœ… Strengths

1. **Correct Goroutine Syntax**: `go functionName()` usage
2. **Wait Strategy**: Used `time.Sleep()` to prevent early exit
3. **Experimentation**: Tested with and without goroutines
4. **Anonymous Functions**: Demonstrated inline goroutines

### âš ï¸ **CRITICAL ISSUES**

#### Issue #1: Spelling

```go
// "intrestng" â†’ "interesting"
```

#### Issue #2: Using `time.Sleep()` for Synchronization (WRONG!)

```go
time.Sleep(time.Millisecond * 300)  // âŒ BAD PRACTICE!
```

**Problems**:

1. **Unreliable**: What if goroutine takes > 300ms?
2. **Wasteful**: What if goroutine finishes in 10ms?
3. **Race Conditions**: No guarantee goroutine completed
4. **Not Scalable**: How long to sleep for 100 goroutines?

**CORRECT WAY**: Use `sync.WaitGroup`

```go
var wg sync.WaitGroup

wg.Add(1)  // Tell WaitGroup we're adding 1 goroutine
go func() {
    defer wg.Done()  // Signal completion
    test()
}()

wg.Wait()  // Block until all goroutines call Done()
```

#### Issue #3: No Demonstration of Concurrency Benefits

Your code shows goroutines run, but not WHY to use them:

- No parallel work demonstration
- No speed comparison
- No real-world use case

**Better Example**:

```go
// Sequential: 4 seconds
start := time.Now()
fetchURL("url1")  // 1s
fetchURL("url2")  // 1s
fetchURL("url3")  // 1s
fetchURL("url4")  // 1s
fmt.Println("Sequential:", time.Since(start))  // ~4s

// Concurrent: 1 second!
start = time.Now()
var wg sync.WaitGroup
for _, url := range urls {
    wg.Add(1)
    go func(u string) {
        defer wg.Done()
        fetchURL(u)  // All run in parallel!
    }(url)
}
wg.Wait()
fmt.Println("Concurrent:", time.Since(start))  // ~1s
```

#### Issue #4: Missing Goroutine Gotchas

**Common Mistakes**:

**A. Loop Variable Capture Bug**:

```go
// WRONG:
for i := 0; i < 3; i++ {
    go func() {
        fmt.Println(i)  // âŒ All print 3!
    }()
}

// RIGHT:
for i := 0; i < 3; i++ {
    go func(i int) {  // Pass as parameter
        fmt.Println(i)  // âœ… Prints 0, 1, 2
    }(i)
}
```

**B. Goroutine Leaks**:

```go
// WRONG:
go func() {
    <-ch  // Blocks forever if nothing sends!
}()
// Goroutine never exits â†’ memory leak!

// RIGHT: Use context or timeout
ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
defer cancel()

go func() {
    select {
    case <-ch:
        // Handle message
    case <-ctx.Done():
        return  // Exit on timeout
    }
}()
```

### ðŸ“š Goroutines Deep Dive

#### What is a Goroutine?

**Definition**: Lightweight thread managed by Go runtime

```go
// Regular function call (blocking)
doWork()  // Wait for completion
fmt.Println("After work")

// Goroutine (non-blocking)
go doWork()  // Don't wait, continue immediately
fmt.Println("After work")  // Prints immediately!
```

#### Goroutine vs OS Thread

| Feature        | Goroutine         | OS Thread     |
| -------------- | ----------------- | ------------- |
| Size           | ~2KB initial      | ~1-2MB        |
| Creation       | Microseconds      | Milliseconds  |
| Count          | Millions possible | Thousands max |
| Scheduling     | Go runtime (M:N)  | OS kernel     |
| Context Switch | Cheap             | Expensive     |

#### Goroutine Lifecycle

```go
// 1. CREATION
go myFunc()  // Spawns new goroutine

// 2. EXECUTION
// Goroutine runs concurrently with main

// 3. COMPLETION
// Goroutine exits when function returns

// 4. CLEANUP
// Runtime automatically cleans up
```

**CRITICAL**: Main goroutine exit kills all goroutines!

```go
func main() {
    go fmt.Println("Hello")
    // main exits immediately â†’ goroutine never runs!
}

func main() {
    go fmt.Println("Hello")
    time.Sleep(time.Second)  // Wait for goroutine
    // Goroutine has time to run âœ…
}
```

### ðŸ”§ Complete Goroutine Examples

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    demonstrateBasicGoroutine()
    demonstrateWaitGroup()
    demonstrateConcurrentWork()
    demonstrateLoopCaptureBug()
    demonstrateAnonymous()
    demonstrateMultiple()
}

// Basic goroutine
func demonstrateBasicGoroutine() {
    fmt.Println("=== Basic Goroutine ===")

    // Regular call (blocking)
    fmt.Println("Before regular call")
    sayHello("Alice")
    fmt.Println("After regular call\n")

    // Goroutine (non-blocking)
    fmt.Println("Before goroutine")
    go sayHello("Bob")
    fmt.Println("After goroutine")

    time.Sleep(100 * time.Millisecond)  // Wait for goroutine
    fmt.Println()
}

func sayHello(name string) {
    time.Sleep(50 * time.Millisecond)
    fmt.Printf("Hello, %s!\n", name)
}

// Proper synchronization with WaitGroup
func demonstrateWaitGroup() {
    fmt.Println("=== WaitGroup ===")

    var wg sync.WaitGroup

    // Launch 3 goroutines
    for i := 1; i <= 3; i++ {
        wg.Add(1)  // Increment counter
        go func(id int) {
            defer wg.Done()  // Decrement when done
            worker(id)
        }(i)
    }

    wg.Wait()  // Block until all Done()
    fmt.Println("All workers completed!\n")
}

func worker(id int) {
    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Duration(id*100) * time.Millisecond)
    fmt.Printf("Worker %d done\n", id)
}

// Demonstrate concurrency benefits
func demonstrateConcurrentWork() {
    fmt.Println("=== Concurrent vs Sequential ===")

    tasks := []string{"Task1", "Task2", "Task3", "Task4"}

    // Sequential
    start := time.Now()
    for _, task := range tasks {
        doTask(task)
    }
    sequential := time.Since(start)

    // Concurrent
    start = time.Now()
    var wg sync.WaitGroup
    for _, task := range tasks {
        wg.Add(1)
        go func(t string) {
            defer wg.Done()
            doTask(t)
        }(task)
    }
    wg.Wait()
    concurrent := time.Since(start)

    fmt.Printf("Sequential: %v\n", sequential)
    fmt.Printf("Concurrent: %v\n", concurrent)
    fmt.Printf("Speedup: %.2fx\n\n", float64(sequential)/float64(concurrent))
}

func doTask(name string) {
    time.Sleep(100 * time.Millisecond)
    fmt.Printf("%s completed\n", name)
}

// Loop variable capture bug
func demonstrateLoopCaptureBug() {
    fmt.Println("=== Loop Variable Capture Bug ===")

    // WRONG WAY:
    fmt.Println("Wrong way:")
    for i := 0; i < 3; i++ {
        go func() {
            fmt.Printf("i = %d\n", i)  // âŒ All reference same i!
        }()
    }
    time.Sleep(100 * time.Millisecond)

    // RIGHT WAY:
    fmt.Println("\nRight way:")
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(i int) {  // Pass as parameter
            defer wg.Done()
            fmt.Printf("i = %d\n", i)  // âœ… Each goroutine gets own copy
        }(i)
    }
    wg.Wait()
    fmt.Println()
}

// Anonymous goroutines
func demonstrateAnonymous() {
    fmt.Println("=== Anonymous Goroutines ===")

    var wg sync.WaitGroup

    // Named function
    wg.Add(1)
    go func() {
        defer wg.Done()
        fmt.Println("Anonymous function 1")
    }()

    // With parameters
    wg.Add(1)
    go func(msg string) {
        defer wg.Done()
        fmt.Println(msg)
    }("Anonymous function 2")

    // With return value (captured in closure)
    result := 0
    wg.Add(1)
    go func() {
        defer wg.Done()
        result = 42  // Modifies outer variable
    }()

    wg.Wait()
    fmt.Printf("Result: %d\n\n", result)
}

// Multiple goroutines
func demonstrateMultiple() {
    fmt.Println("=== Multiple Goroutines ===")

    var wg sync.WaitGroup

    // Launch 10 goroutines
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Printf("Goroutine %d running\n", id)
        }(i)
    }

    wg.Wait()
    fmt.Println("All goroutines completed!\n")
}

/*
GOROUTINE FUNDAMENTALS:

1. SYNTAX:
   go functionName()        // Named function
   go func() { ... }()      // Anonymous function
   go obj.method()          // Method call

2. EXECUTION:
   - Goroutines run concurrently
   - Execution order is non-deterministic
   - Main goroutine exit kills all goroutines

3. SYNCHRONIZATION:
   âœ… sync.WaitGroup (wait for completion)
   âœ… Channels (communication + sync)
   âœ… sync.Mutex (protect shared data)
   âŒ time.Sleep (unreliable!)

4. COMMON PATTERNS:

   a) Worker Pool:
   for i := 0; i < numWorkers; i++ {
       go worker(jobs, results)
   }

   b) Fan-Out:
   for _, task := range tasks {
       go process(task)
   }

   c) Fan-In:
   for result := range results {
       aggregate(result)
   }

5. GOTCHAS:

   a) Loop Variable Capture:
   for i := range items {
       go func() { use(i) }()  // âŒ Wrong!
       go func(i int) { use(i) }(i)  // âœ… Right!
   }

   b) Goroutine Leaks:
   go func() {
       <-ch  // âŒ Blocks forever if ch never receives
   }()

   c) Race Conditions:
   count := 0
   for i := 0; i < 100; i++ {
       go func() { count++ }()  // âŒ Race!
   }

6. BEST PRACTICES:

   âœ… Use WaitGroup or channels for synchronization
   âœ… Pass loop variables as parameters
   âœ… Use defer wg.Done() to guarantee cleanup
   âœ… Handle errors from goroutines via channels
   âœ… Use context for cancellation
   âŒ Don't use time.Sleep for synchronization
   âŒ Don't leak goroutines
   âŒ Don't access shared data without locks

7. DEBUGGING:

   // Runtime stats
   fmt.Println("NumGoroutine:", runtime.NumGoroutine())

   // Race detector
   go run -race main.go

   // Profiling
   import _ "net/http/pprof"
   go tool pprof http://localhost:6060/debug/pprof/goroutine
*/
```

### ðŸŽ¯ Your Code Enhanced

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    demonstrateOriginal()
    demonstrateFixed()
}

// Your original approach
func demonstrateOriginal() {
    fmt.Println("=== Original (with time.Sleep) ===")

    go test()
    time.Sleep(time.Millisecond * 300)  // âŒ Unreliable!

    go func() {
        fmt.Println("I am an anonymous func :)")
    }()
    time.Sleep(time.Millisecond * 300)  // âŒ Unreliable!
}

// Fixed version
func demonstrateFixed() {
    fmt.Println("\n=== Fixed (with WaitGroup) ===")

    var wg sync.WaitGroup

    wg.Add(1)
    go func() {
        defer wg.Done()
        test()
    }()

    wg.Add(1)
    go func() {
        defer wg.Done()
        fmt.Println("I am an anonymous func :)")
    }()

    wg.Wait()  // âœ… Reliable!
}

func test() {
    fmt.Println("This is goRutine :)")
}
```

---

## Rating Breakdown

| Category        | Rating | Comments                            |
| --------------- | ------ | ----------------------------------- |
| Understanding   | 7/10   | Understands goroutine basics        |
| Synchronization | 4/10   | Using time.Sleep is wrong!          |
| Examples        | 6/10   | Basic demos, missing real use cases |
| Code Quality    | 8/10   | Clean, readable code                |

**Overall: 7/10**

---

## Key Takeaways

1. âœ… **Goroutines**: Lightweight, use `go func()`
2. âŒ **Never use `time.Sleep` for sync** - use WaitGroup!
3. âœ… **Main exit kills all goroutines** - must wait
4. âš ï¸ **Loop variable capture** - pass as parameter!
5. âœ… **`defer wg.Done()`** ensures cleanup
6. âœ… **Concurrency â‰  Parallelism** (separate concepts)

---

## Next Steps

1. âœ… Replace ALL `time.Sleep()` with `sync.WaitGroup`
2. âœ… Practice loop variable capture correctly
3. âœ… Measure concurrent vs sequential performance
4. âœ… Learn goroutine leaks and prevention
5. âœ… Study `context` for cancellation
6. âœ… Run code with `-race` flag
7. âœ… Read: https://go.dev/blog/pipelines

**Good start! But NEVER use time.Sleep for synchronization. Learn WaitGroup and channels!** ðŸš€
