# Code Review: 0.0012/concurrency/test/concurrency_test.go

## Overall Assessment

**File Purpose**: Tests for goroutines and channels  
**Rating**: 5/10  
**Status**: NO ASSERTIONS - tests don't verify anything!

---

## Detailed Review

### File Structure

```go
// Test functions:
1. testGoRutines()    # ‚ùå Lowercase 't' - WON'T RUN!
2. TestChannels()     # ‚úÖ Runs, calls T1, T3, B1-B9
```

---

## CRITICAL ISSUES

### Issue #1: testGoRutines Won't Run

```go
func testGoRutines(t *testing.T) {  // ‚ùå Lowercase 't'
    concurrency.C1()
}
```

**Problem**: Go test runner ONLY runs functions starting with `Test` (capital T)!

**This test is NEVER executed!**

**Fix:**

```go
func TestGoRutines(t *testing.T) {  // ‚úÖ Capital T
    concurrency.C1()
}
```

**To verify:**

```bash
$ go test -v
# Only sees TestChannels, not testGoRutines!
```

---

### Issue #2: NO ASSERTIONS ANYWHERE

```go
func TestChannels(t *testing.T) {
    concurrency.T1()
    // concurrency.T2()
    concurrency.T3()
    concurrency.B1()
    concurrency.B2()
    concurrency.B3()
    concurrency.B4()
    concurrency.B5()
    concurrency.B6()
    concurrency.B7()
    concurrency.B8()
    concurrency.B9()
}
```

**Problem**: This just CALLS functions! It doesn't VERIFY anything!

**Tests always pass, even if code is broken!**

**What's missing:**

```go
// ‚ùå No t.Assert*
// ‚ùå No t.Error*
// ‚ùå No t.Fatal*
// ‚ùå No if statements checking results
```

**Example fix for channels:**

```go
func TestUnbufferedChannel(t *testing.T) {
    ch := make(chan int)

    // Test sending/receiving works
    go func() {
        ch <- 42
    }()

    received := <-ch
    if received != 42 {
        t.Errorf("Expected 42, got %d", received)
    }
}

func TestBufferedChannel(t *testing.T) {
    ch := make(chan int, 3)

    // Should accept 3 values without blocking
    ch <- 1
    ch <- 2
    ch <- 3

    // Verify values in correct order
    if v := <-ch; v != 1 {
        t.Errorf("Expected 1, got %d", v)
    }
    if v := <-ch; v != 2 {
        t.Errorf("Expected 2, got %d", v)
    }
    if v := <-ch; v != 3 {
        t.Errorf("Expected 3, got %d", v)
    }
}
```

---

### Issue #3: T2 Commented Out

```go
// concurrency.T2()
```

**Why?** I see in channels.go you commented T2 with:

```go
// func T2() {
//     // Commented because it causes deadlock
// }
```

**Good!** You learned that sending to unbuffered channel without receiver blocks!

**But in test:** Document WHY it's commented:

```go
func TestChannels(t *testing.T) {
    concurrency.T1()
    // concurrency.T2() // Commented: demonstrates deadlock - can't test this way
    concurrency.T3()
    // ...
}
```

---

### Issue #4: No Test for Goroutines

Your `testGoRutines` (which doesn't run) just calls `C1()`:

```go
func testGoRutines(t *testing.T) {
    concurrency.C1()  // ‚ùå No verification!
}
```

**What should you test about goroutines?**

```go
func TestGoRoutine(t *testing.T) {
    // Test that goroutine runs
    done := make(chan bool)

    go func() {
        // Do work
        done <- true
    }()

    // Wait for completion
    select {
    case <-done:
        // Success!
    case <-time.After(1 * time.Second):
        t.Fatal("Goroutine didn't complete in time")
    }
}

func TestMultipleGoRoutines(t *testing.T) {
    const numRoutines = 5
    done := make(chan int, numRoutines)

    for i := 0; i < numRoutines; i++ {
        go func(id int) {
            done <- id
        }(i)
    }

    // Verify all completed
    results := make(map[int]bool)
    for i := 0; i < numRoutines; i++ {
        id := <-done
        results[id] = true
    }

    if len(results) != numRoutines {
        t.Errorf("Expected %d routines, got %d", numRoutines, len(results))
    }
}
```

---

### Issue #5: No WaitGroup in Code

**Note**: Your goRutines.go uses `time.Sleep(time.Second)` to wait:

```go
func WaitToGetGet() {
    go get("first")
    time.Sleep(time.Second)  // ‚ö†Ô∏è Not ideal!
}
```

**Better approach with WaitGroup:**

```go
func WaitToGetGet() {
    var wg sync.WaitGroup
    wg.Add(1)

    go func() {
        defer wg.Done()
        get("first")
    }()

    wg.Wait()  // ‚úÖ Waits exactly until goroutine finishes
}
```

**Why better?**

- `time.Sleep` is a GUESS - might be too short OR too long
- `WaitGroup` waits EXACTLY until work completes

**Test it:**

```go
func TestWaitGroup(t *testing.T) {
    var wg sync.WaitGroup
    counter := 0

    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter++
        }()
    }

    wg.Wait()

    if counter != 10 {
        t.Errorf("Expected counter=10, got %d", counter)
    }
}
```

---

## Summary

### What You Did ‚úÖ

1. **Called channel functions**: T1, T3, B1-B9
2. **Commented broken T2**: Shows you understand deadlocks!
3. **Organized tests**: Separate functions for channels vs goroutines

### Critical Problems ‚ùå

1. **testGoRutines won't run** - lowercase 't'
2. **NO assertions** - tests don't verify anything!
3. **time.Sleep instead of WaitGroup** - unreliable timing
4. **No actual test logic** - just function calls

### Must Fix

```go
// ‚ùå Current:
func TestChannels(t *testing.T) {
    concurrency.T1()  // Just calls function
}

// ‚úÖ Should be:
func TestChannels(t *testing.T) {
    ch := make(chan int)

    go func() { ch <- 42 }()

    result := <-ch
    if result != 42 {
        t.Errorf("Expected 42, got %d", result)
    }
}
```

---

## Learning Points üìö

### What Tests Should Do

1. **Setup**: Create test data/conditions
2. **Execute**: Run the code
3. **Verify**: CHECK results with assertions!
4. **Cleanup**: If needed

### Example Pattern

```go
func TestX(t *testing.T) {
    // Arrange
    input := someValue

    // Act
    result := FunctionToTest(input)

    // Assert
    if result != expected {
        t.Errorf("Expected %v, got %v", expected, result)
    }
}
```

### Your Current Tests

```go
// ‚ùå You only do "Act" - no "Assert"!
func TestChannels(t *testing.T) {
    concurrency.T1()  // Act
    // ‚ùå Missing: if result != expected { t.Error() }
}
```

---

## Recommended Fixes

### 1. Fix Function Name

```go
func TestGoRutines(t *testing.T) {  // Capital T
    // Now will run!
}
```

### 2. Add Real Channel Tests

```go
func TestUnbufferedChannel(t *testing.T) {
    ch := make(chan string)
    expected := "hello"

    go func() {
        ch <- expected
    }()

    received := <-ch
    if received != expected {
        t.Errorf("Expected %s, got %s", expected, received)
    }
}

func TestBufferedChannel(t *testing.T) {
    ch := make(chan int, 2)

    // Should not block
    ch <- 1
    ch <- 2

    // Verify FIFO
    if v := <-ch; v != 1 {
        t.Errorf("Expected 1, got %d", v)
    }
    if v := <-ch; v != 2 {
        t.Errorf("Expected 2, got %d", v)
    }
}
```

### 3. Add Goroutine Tests

```go
func TestGoRoutineCompletes(t *testing.T) {
    done := make(chan bool, 1)

    go func() {
        // Simulate work
        time.Sleep(10 * time.Millisecond)
        done <- true
    }()

    select {
    case <-done:
        // Success
    case <-time.After(1 * time.Second):
        t.Fatal("Goroutine didn't complete")
    }
}
```

---

## Final Grade: D

**Why D?**

- ‚ùå One test doesn't even run (lowercase name)
- ‚ùå Zero assertions - can't catch bugs!
- ‚ùå Just calls functions without checking results
- ‚úÖ But: You organized the code and understand deadlocks

**To get A:**

1. Fix function name: `TestGoRutines`
2. Add assertions to every test
3. Use WaitGroup instead of time.Sleep
4. Test actual behavior, not just "does it crash?"

**Tests without assertions are like code without output - you have no idea if it works!**
