# Code Review: 0.0010/scope/main.go

## Overall Assessment

**File Purpose**: Understand variable shadowing in Go  
**Rating**: 6.5/10  
**Status**: Demonstrates shadowing but needs deeper exploration!

---

## Detailed Review

### ‚úÖ Strengths

1. **Valid Demonstration**: Shows inner vs outer scope
2. **Correct Syntax**: Code compiles and runs
3. **Clear Output**: Shows 10 vs 20 difference

### ‚ö†Ô∏è **CRITICAL ISSUES**

#### Issue #1: Misleading Comment

```go
// this is true in C and javascript but golang has some differnce
```

**Actually, Go's scoping works EXACTLY like C and JavaScript!**

**Comparison**:

```c
// C - SAME BEHAVIOR!
#include <stdio.h>
int main() {
    int x = 10;
    printf("%d\n", x);  // 10
    {
        int x = 20;     // Shadows outer x
        printf("%d\n", x);  // 20
    }
    printf("%d\n", x);  // 10
}
```

```javascript
// JavaScript - SAME BEHAVIOR!
let x = 10;
console.log(x); // 10
{
  let x = 20; // Shadows outer x
  console.log(x); // 20
}
console.log(x); // 10
```

```go
// Go - IDENTICAL!
x := 10
fmt.Println(x)  // 10
{
    x := 20     // Shadows outer x
    fmt.Println(x)  // 20
}
fmt.Println(x)  // 10
```

‚úÖ **All three languages behave identically!** Go is **not** different here.

#### Issue #2: Spelling

```go
// "differnce" ‚Üí "difference"
```

#### Issue #3: Incomplete Exploration

Your code only shows **one pattern** of shadowing. Missing:

- Function parameter shadowing
- Loop variable shadowing
- Import shadowing
- Multiple block levels
- Short declaration (:=) vs assignment (=) confusion

### üìö Variable Shadowing Deep Dive

#### What is Shadowing?

**Definition**: Inner scope variable "hides" outer scope variable with same name.

```go
x := 10        // Outer scope
{
    x := 20    // SHADOWS (new variable!)
    // Inner x hides outer x
}
// Outer x still 10
```

#### Shadowing vs Reassignment

```go
// REASSIGNMENT (same variable)
x := 10
x = 20         // Modifies outer x
fmt.Println(x) // 20

// SHADOWING (new variable)
x := 10
{
    x := 20    // NEW variable, shadows outer
    fmt.Println(x)  // 20
}
fmt.Println(x) // 10 (outer unchanged!)
```

**Key Difference**: `:=` creates NEW variable, `=` modifies existing.

#### Common Shadowing Scenarios

**1. Block Scope**

```go
x := 1
{
    x := 2  // Shadows
    {
        x := 3  // Shadows again
        fmt.Println(x)  // 3
    }
    fmt.Println(x)  // 2
}
fmt.Println(x)  // 1
```

**2. If Statements**

```go
x := 1
if x := 2; x > 0 {  // Shadows!
    fmt.Println(x)  // 2
}
fmt.Println(x)  // 1
```

**3. For Loops**

```go
x := 0
for x := 1; x < 3; x++ {  // Shadows!
    fmt.Println(x)  // 1, 2
}
fmt.Println(x)  // 0 (unchanged!)
```

**4. Function Parameters**

```go
x := 10

func test(x int) {  // Shadows outer x
    fmt.Println(x)  // Uses parameter
    x = 99          // Modifies parameter only
}

test(20)  // 20
fmt.Println(x)  // 10 (outer unchanged!)
```

**5. Range Loops**

```go
i := 999
for i := range []int{1, 2, 3} {  // Shadows!
    fmt.Println(i)  // 0, 1, 2
}
fmt.Println(i)  // 999
```

#### Dangerous Shadowing (Common Bug!)

```go
// ERROR SHADOWING BUG!
var err error
data, err := readFile("a.txt")  // ‚úÖ err assigned

data, err := readFile("b.txt")  // ‚ùå SHADOWS! Creates NEW err
// Old err is hidden, new err shadows it

// FIX:
var err error
data, err := readFile("a.txt")
data, err = readFile("b.txt")  // ‚úÖ Reuses same err
```

### üîß Complete Shadowing Examples

```go
package main

import "fmt"

func main() {
    demonstrateBasicShadowing()
    demonstrateIfShadowing()
    demonstrateLoopShadowing()
    demonstrateMultiLevel()
    demonstrateErrorShadowing()
    demonstrateDangerousPatterns()
}

func demonstrateBasicShadowing() {
    fmt.Println("=== Basic Shadowing ===")

    x := 10
    fmt.Printf("Outer x: %d (addr: %p)\n", x, &x)

    {
        x := 20  // NEW variable
        fmt.Printf("Inner x: %d (addr: %p)\n", x, &x)
        x = 25   // Modify inner x
        fmt.Printf("Modified inner: %d\n", x)
    }

    fmt.Printf("Outer x after block: %d\n", x)  // Still 10!
    fmt.Println()
}

func demonstrateIfShadowing() {
    fmt.Println("=== If Statement Shadowing ===")

    x := 1

    // Shadowing in if condition
    if x := 2; x > 0 {
        fmt.Printf("Inside if: x = %d\n", x)

        // Another shadow!
        if x := 3; x > 0 {
            fmt.Printf("Nested if: x = %d\n", x)
        }

        fmt.Printf("Back to first if: x = %d\n", x)
    }

    fmt.Printf("Outside if: x = %d\n", x)
    fmt.Println()
}

func demonstrateLoopShadowing() {
    fmt.Println("=== Loop Shadowing ===")

    i := 999
    sum := 0

    // for loop shadows i
    for i := 0; i < 3; i++ {
        fmt.Printf("Loop i: %d\n", i)
        sum += i
    }

    fmt.Printf("Outer i: %d (unchanged!)\n", i)
    fmt.Printf("Sum: %d\n", sum)

    // Range shadows i again
    for i := range []string{"a", "b"} {
        fmt.Printf("Range i: %d\n", i)
    }

    fmt.Printf("Outer i still: %d\n", i)
    fmt.Println()
}

func demonstrateMultiLevel() {
    fmt.Println("=== Multi-Level Shadowing ===")

    x := 1
    fmt.Printf("Level 0: x = %d\n", x)

    {
        x := 2
        fmt.Printf("Level 1: x = %d\n", x)

        {
            x := 3
            fmt.Printf("Level 2: x = %d\n", x)

            {
                x := 4
                fmt.Printf("Level 3: x = %d\n", x)
            }

            fmt.Printf("Back to Level 2: x = %d\n", x)
        }

        fmt.Printf("Back to Level 1: x = %d\n", x)
    }

    fmt.Printf("Back to Level 0: x = %d\n", x)
    fmt.Println()
}

func demonstrateErrorShadowing() {
    fmt.Println("=== Error Shadowing (DANGEROUS!) ===")

    // WRONG WAY:
    demonstrateBuggyErrorHandling()

    // RIGHT WAY:
    demonstrateCorrectErrorHandling()
    fmt.Println()
}

func demonstrateBuggyErrorHandling() {
    fmt.Println("Buggy version:")

    var data string
    var err error

    // First call
    data, err := "file1", error(nil)  // SHADOWS err!
    if err != nil {
        fmt.Println("Error 1:", err)
    }
    fmt.Println("Data 1:", data)

    // Second call
    data, err := "file2", fmt.Errorf("oops")  // SHADOWS again!
    if err != nil {
        fmt.Println("Error 2:", err)  // Uses shadowed err
    }

    // Original err is still nil!
    fmt.Printf("Original err: %v\n", err)
}

func demonstrateCorrectErrorHandling() {
    fmt.Println("Correct version:")

    var data string
    var err error

    // First call
    data, err = "file1", error(nil)  // ASSIGNS (no :=)
    if err != nil {
        fmt.Println("Error 1:", err)
    }
    fmt.Println("Data 1:", data)

    // Second call
    data, err = "file2", fmt.Errorf("oops")  // ASSIGNS
    if err != nil {
        fmt.Println("Error 2:", err)
    }

    // err is properly set!
    fmt.Printf("Final err: %v\n", err)
}

func demonstrateDangerousPatterns() {
    fmt.Println("=== Dangerous Shadowing Patterns ===")

    // Pattern 1: Accidental shadowing
    result := 0
    if result := compute(); result > 0 {  // SHADOWS!
        fmt.Println("If result:", result)
        // Modifying this result doesn't affect outer
    }
    fmt.Println("Outer result:", result)  // Still 0!

    // Pattern 2: Import shadowing
    // This compiles but is VERY confusing:
    fmt := "my custom fmt"  // Shadows package!
    // fmt.Println won't work here!
    _ = fmt

    fmt.Println("Back to normal")  // Works again (in outer scope)
}

func compute() int {
    return 42
}

/*
SHADOWING RULES:

1. SCOPE HIERARCHY:
   - Package scope (widest)
   - File scope
   - Function scope
   - Block scope (narrowest)
   Inner scopes can shadow outer scopes

2. DECLARATION:
   := creates NEW variable (can shadow)
   =  assigns to EXISTING variable (no shadow)

3. LIFETIME:
   - Shadowing variable exists only in its block
   - Original variable unchanged after block ends

4. GOTCHAS:
   a) if x := ...; condition { } shadows outer x
   b) for x := ...; condition; ... { } shadows outer x
   c) for x := range ... { } shadows outer x
   d) err shadowing is the MOST common bug!

5. BEST PRACTICES:
   ‚úÖ Avoid shadowing when possible
   ‚úÖ Use different names in nested scopes
   ‚úÖ Watch for := in if/for conditions
   ‚ùå Don't shadow err in multiple if blocks
   ‚ùå Don't shadow package names (like fmt)

6. DETECTION:
   - go vet catches some shadowing
   - Use shadow checker: go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow@latest
   - Run: shadow ./...

C/JAVASCRIPT COMPARISON:
‚úÖ C: { int x = ...; } works identically
‚úÖ JavaScript: { let x = ...; } works identically
‚úÖ Python: NO block scope (different!)
‚úÖ Go: { x := ...; } identical to C/JS

Go is NOT different from C/JavaScript in scoping!
*/
```

---

## Rating Breakdown

| Category      | Rating | Comments                           |
| ------------- | ------ | ---------------------------------- |
| Understanding | 6/10   | Basic concept shown, depth missing |
| Accuracy      | 5/10   | Wrong claim about C/JS difference  |
| Examples      | 5/10   | Only shows simple case             |
| Code Quality  | 8/10   | Clean, runnable code               |

**Overall: 6.5/10**

---

## Key Takeaways

1. ‚úÖ **Shadowing**: Inner scope hides outer scope variable
2. ‚ùå **Go is NOT different** from C/JavaScript in scoping!
3. ‚úÖ **:= creates new** variable (can shadow)
4. ‚úÖ **= assigns** to existing (no shadow)
5. ‚ö†Ô∏è **err shadowing** is #1 bug in Go!
6. ‚úÖ **Use `shadow` tool** to detect issues

---

## Next Steps

1. ‚úÖ Test shadowing in if statements
2. ‚úÖ Test shadowing in for loops
3. ‚úÖ Practice error shadowing prevention
4. ‚úÖ Install shadow tool: `go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow@latest`
5. ‚úÖ Run: `shadow ./...` on your code
6. ‚úÖ Compare C/JavaScript scoping (they're the same!)
7. ‚úÖ Read: https://golang.org/doc/effective_go#redeclaration

**Good start! But Go's scoping is identical to C and JavaScript. Explore more shadowing patterns!** üéØ
