# Code Review: 0.0012/concurrency/select.go

## Overall Assessment

**File Purpose**: Learn select statement for channel multiplexing  
**Rating**: N/A (Empty File)  
**Status**: Not implemented yet

---

## File Contents

```go
package concurrency
```

**The file only contains a package declaration - no code yet!**

---

## What `select` Is For

The `select` statement is one of Go's most powerful concurrency features. It allows you to:

1. **Wait on multiple channels** simultaneously
2. **Handle timeouts** gracefully
3. **Implement non-blocking operations** with `default`
4. **Multiplex** channel operations

---

## ðŸ“š Select Statement Guide

### Basic Syntax

```go
select {
case val := <-ch1:
    // Handle value from ch1
case val := <-ch2:
    // Handle value from ch2
case ch3 <- value:
    // Send value to ch3
default:
    // Execute if no channel ready (non-blocking)
}
```

### How It Works

1. **Evaluates all cases** simultaneously
2. **Waits** until one case can proceed
3. **Randomly chooses** if multiple ready
4. **Executes default** if no case ready (non-blocking)

---

## ðŸ”§ Complete Select Examples

```go
package concurrency

import (
    "fmt"
    "time"
)

func main() {
    demonstrateBasicSelect()
    demonstrateTimeout()
    demonstrateNonBlocking()
    demonstrateMultipleChannels()
    demonstratePriority()
    demonstrateLoopSelect()
}

// Example 1: Basic select
func demonstrateBasicSelect() {
    fmt.Println("=== Basic Select ===")

    ch1 := make(chan string)
    ch2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "from ch1"
    }()

    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "from ch2"
    }()

    // Wait for first to arrive
    select {
    case msg1 := <-ch1:
        fmt.Println("Received:", msg1)
    case msg2 := <-ch2:
        fmt.Println("Received:", msg2)
    }
    fmt.Println()
}

// Example 2: Timeout pattern
func demonstrateTimeout() {
    fmt.Println("=== Timeout Pattern ===")

    ch := make(chan string)

    go func() {
        time.Sleep(2 * time.Second)  // Slow operation
        ch <- "result"
    }()

    select {
    case res := <-ch:
        fmt.Println("Got result:", res)
    case <-time.After(1 * time.Second):
        fmt.Println("Timeout! Operation took too long")
    }
    fmt.Println()
}

// Example 3: Non-blocking operations
func demonstrateNonBlocking() {
    fmt.Println("=== Non-Blocking Operations ===")

    ch := make(chan int)

    // Non-blocking send
    select {
    case ch <- 42:
        fmt.Println("Sent value")
    default:
        fmt.Println("No receiver ready, skipping send")
    }

    // Non-blocking receive
    select {
    case val := <-ch:
        fmt.Printf("Received %d\n", val)
    default:
        fmt.Println("No sender ready, skipping receive")
    }
    fmt.Println()
}

// Example 4: Multiple channels
func demonstrateMultipleChannels() {
    fmt.Println("=== Multiple Channels ===")

    ch1 := make(chan int)
    ch2 := make(chan int)
    ch3 := make(chan int)
    quit := make(chan bool)

    // Producers
    go func() {
        for i := 0; i < 3; i++ {
            time.Sleep(100 * time.Millisecond)
            ch1 <- i
        }
    }()

    go func() {
        for i := 10; i < 13; i++ {
            time.Sleep(150 * time.Millisecond)
            ch2 <- i
        }
    }()

    go func() {
        time.Sleep(500 * time.Millisecond)
        quit <- true
    }()

    // Consumer
    for {
        select {
        case v1 := <-ch1:
            fmt.Printf("From ch1: %d\n", v1)
        case v2 := <-ch2:
            fmt.Printf("From ch2: %d\n", v2)
        case v3 := <-ch3:
            fmt.Printf("From ch3: %d\n", v3)
        case <-quit:
            fmt.Println("Quit signal received")
            return
        }
    }
}

// Example 5: Priority select (not directly supported, use nested selects)
func demonstratePriority() {
    fmt.Println("=== Priority Select ===")

    high := make(chan string, 5)
    low := make(chan string, 5)

    // Fill both channels
    high <- "HIGH-1"
    high <- "HIGH-2"
    low <- "low-1"
    low <- "low-2"

    // Process high priority first
    for i := 0; i < 4; i++ {
        select {
        case msg := <-high:
            fmt.Println("Priority:", msg)
        default:
            // Only check low if high is empty
            select {
            case msg := <-low:
                fmt.Println("Normal:", msg)
            default:
                fmt.Println("All empty")
            }
        }
    }
    fmt.Println()
}

// Example 6: Select in loop (common pattern)
func demonstrateLoopSelect() {
    fmt.Println("=== Select in Loop ===")

    jobs := make(chan int, 5)
    done := make(chan bool)

    // Producer
    go func() {
        for i := 1; i <= 5; i++ {
            jobs <- i
        }
        close(jobs)
    }()

    // Consumer with timeout
    go func() {
        for {
            select {
            case job, ok := <-jobs:
                if !ok {
                    done <- true
                    return
                }
                fmt.Printf("Processing job %d\n", job)
                time.Sleep(100 * time.Millisecond)
            case <-time.After(2 * time.Second):
                fmt.Println("Job timeout!")
                done <- true
                return
            }
        }
    }()

    <-done
}

// ADVANCED PATTERNS

// Pattern 1: Fan-in (combine multiple channels)
func fanIn(ch1, ch2 <-chan string) <-chan string {
    out := make(chan string)
    go func() {
        for {
            select {
            case msg := <-ch1:
                out <- msg
            case msg := <-ch2:
                out <- msg
            }
        }
    }()
    return out
}

// Pattern 2: Cancellation with context
func demoSelectWithContext() {
    // This would use context.Context
    // select {
    // case <-ctx.Done():
    //     return ctx.Err()
    // case result := <-work():
    //     return result
    // }
}

/*
SELECT RULES:

1. SYNTAX:
   select {
   case v := <-ch:      // Receive
   case ch <- v:        // Send
   default:             // Non-blocking
   }

2. EVALUATION:
   - All channel operations evaluated
   - Waits until one can proceed
   - Random selection if multiple ready
   - default executes immediately if none ready

3. BLOCKING:
   - WITHOUT default: blocks until case ready
   - WITH default: never blocks

4. COMMON PATTERNS:

   a) Timeout:
   select {
   case res := <-ch:
   case <-time.After(1*time.Second):
   }

   b) Non-blocking:
   select {
   case ch <- v:
   default:
   }

   c) Quit channel:
   select {
   case data := <-dataCh:
   case <-quit:
       return
   }

   d) Multiple sources:
   select {
   case v := <-ch1:
   case v := <-ch2:
   case v := <-ch3:
   }

5. GOTCHAS:

   âŒ Empty select{} blocks forever (like for{})

   âŒ Nil channel in select is ignored:
   var ch chan int  // nil
   select {
   case <-ch:  // Never executes
   }

   âŒ Random selection (no priority):
   // Both ready â†’ random choice
   select {
   case <-ch1:
   case <-ch2:  // No guaranteed order!
   }

6. VS IF-ELSE:

   âŒ Wrong:
   if <-ch1 {
       // Can't do this!
   }

   âœ… Right:
   select {
   case v := <-ch1:
       // Handle v
   }

7. BEST PRACTICES:

   âœ… Use for timeout patterns
   âœ… Combine with for loop for continuous processing
   âœ… Use default for non-blocking
   âœ… Handle closed channels: v, ok := <-ch
   âŒ Don't assume case order
   âŒ Don't use select for single channel
*/
```

---

## Common Select Patterns

### Pattern 1: Timeout

```go
select {
case result := <-ch:
    fmt.Println("Got result:", result)
case <-time.After(5 * time.Second):
    fmt.Println("Timeout!")
}
```

### Pattern 2: Non-Blocking Send/Receive

```go
select {
case ch <- value:
    fmt.Println("Sent")
default:
    fmt.Println("Channel full")
}
```

### Pattern 3: Quit Channel

```go
for {
    select {
    case work := <-workCh:
        process(work)
    case <-quit:
        return
    }
}
```

### Pattern 4: Fan-In (Merge Channels)

```go
for {
    select {
    case v := <-ch1:
        handle(v)
    case v := <-ch2:
        handle(v)
    case v := <-ch3:
        handle(v)
    }
}
```

---

## When to Use Select

| Use Case              | Pattern                      |
| --------------------- | ---------------------------- |
| Timeout operation     | `case <-time.After()`        |
| Try send/receive      | `default` clause             |
| Multiple data sources | Multiple `case <-ch`         |
| Graceful shutdown     | `case <-quit`                |
| First to respond      | Multiple cases, one executes |

---

## Next Steps for select.go

1. âœ… Implement basic select with 2 channels
2. âœ… Add timeout pattern with `time.After()`
3. âœ… Demonstrate non-blocking with `default`
4. âœ… Show quit channel pattern
5. âœ… Build fan-in example
6. âœ… Test with your channels.go code
7. âœ… Write tests in concurrency_test.go

---

## Suggested Implementation

```go
package concurrency

import (
    "fmt"
    "time"
)

// S1: Basic select
func S1() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    go func() { ch1 <- "from ch1" }()
    go func() { ch2 <- "from ch2" }()

    select {
    case msg := <-ch1:
        fmt.Println(msg)
    case msg := <-ch2:
        fmt.Println(msg)
    }
}

// S2: Timeout
func S2() {
    ch := make(chan string)

    select {
    case msg := <-ch:
        fmt.Println(msg)
    case <-time.After(1 * time.Second):
        fmt.Println("Timeout!")
    }
}

// S3: Non-blocking
func S3() {
    ch := make(chan int)

    select {
    case ch <- 42:
        fmt.Println("Sent")
    default:
        fmt.Println("No receiver")
    }
}

// Continue with more examples...
```

---

## Key Takeaways

1. **Select** = switch for channels
2. **Waits** on multiple channels simultaneously
3. **Random** selection if multiple ready
4. **Timeout** pattern with `time.After()`
5. **Non-blocking** with `default`
6. **Powerful** for orchestrating goroutines

---

**Recommendation**: Implement select.go following your excellent channels.go pattern! Use S1, S2, S3... for different scenarios like you used B1, B2, B3... for buffered channels. ðŸš€

**Your systematic approach in channels.go was perfect - apply it here too!**
