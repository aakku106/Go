# Code Review: 0.0010/errorHandeling/main.go

## Overall Assessment

**File Purpose**: Practice error handling patterns - comma-ok, type assertions, custom errors  
**Rating**: 8.5/10  
**Status**: Excellent! Shows deep understanding of Go idioms

---

## Detailed Review

### ‚úÖ Strengths

1. **Multiple Patterns**: Covered function errors, map checking, type assertions
2. **Good Explanations**: Detailed comments explaining concepts
3. **Comma-OK Pattern**: Used correctly in multiple contexts
4. **Type Assertions**: Excellent understanding and examples
5. **Proper Nil Map Handling**: Used `make` correctly!

### ‚ö†Ô∏è **MINOR ISSUES**

#### Issue #1: Spelling

```go
// "fo rerror" ‚Üí "for error"
// "thers" ‚Üí "there's"
// "seperate" ‚Üí "separate"
// "aal" ‚Üí "all"
// "chayous" ‚Üí "chaos"
// "keywoard" ‚Üí "keyword"
// "inglish" ‚Üí "English"
```

#### Issue #2: Typo in Map Key

```go
if price, ok := stock["appl"]; ok {  // ‚Üê lowercase 'a'
    fmt.Println("Appl stock value: ", price)
} else {
    fmt.Println("aal not found")  // ‚Üê Says "aal not found"
} //cause a is capital A  // ‚Üê Comment explains it
```

This is **intentional** to show case sensitivity, but error message is confusing ("aal" instead of "appl").

**Better**:

```go
if price, ok := stock["appl"]; ok {
    fmt.Println("appl stock value: ", price)
} else {
    fmt.Println("appl not found (case sensitive!)")
}
```

#### Issue #3: Empty Interface Naming

```go
var i interface{} = "awwwwwwwwwwwwww"
```

**Better naming**:

```go
var value interface{} = "Hello, World!"
// or in modern Go (1.18+)
var value any = "Hello, World!"
```

### üìö Error Handling Patterns

#### Pattern 1: Function Returning Error

```go
// Your implementation (excellent!)
func isEven(n int) (bool, error) {
    if n&1 == 1 {
        return false, fmt.Errorf("It's Odd")
    }
    return true, nil
}

// Usage
if ok, err := isEven(10); ok {
    fmt.Println("It's even")
} else {
    fmt.Println(err)
}
```

‚úÖ **Perfect!** This is idiomatic Go.

**Advanced version**:

```go
import "errors"

var ErrOddNumber = errors.New("number is odd")

func isEven(n int) (bool, error) {
    if n&1 == 1 {
        return false, ErrOddNumber
    }
    return true, nil
}

// Caller can check specific error
if ok, err := isEven(11); err != nil {
    if errors.Is(err, ErrOddNumber) {
        fmt.Println("Got expected odd number error")
    }
}
```

#### Pattern 2: Map Comma-OK

```go
// Your code (excellent!)
stock := make(map[string]float64)
stock["Appl"] = 321.123

if price, ok := stock["Appl"]; ok {
    fmt.Println("Appl stock value: ", price)
} else {
    fmt.Println("not found")
}
```

‚úÖ **Perfect!** Idiomatic map checking.

#### Pattern 3: Type Assertion

```go
// Your code (great!)
var i interface{} = "awwwwwwwwwwwwww"
if n, ok := i.(int); ok {
    fmt.Println(n, " is int")
} else {
    fmt.Println("Its not int")
}
```

‚úÖ **Correct!** Comma-OK pattern prevents panic.

**Without comma-OK** (dangerous):

```go
n := i.(int)  // ‚ùå PANIC if i is not int!
```

**Type Switch** (better for multiple types):

```go
var value any = "Hello"

switch v := value.(type) {
case int:
    fmt.Printf("Integer: %d\n", v)
case string:
    fmt.Printf("String: %s\n", v)
case bool:
    fmt.Printf("Boolean: %v\n", v)
default:
    fmt.Printf("Unknown type: %T\n", v)
}
```

### üîß Complete Error Handling Examples

```go
package main

import (
    "errors"
    "fmt"
)

func main() {
    demonstrateFunctionErrors()
    demonstrateMapErrors()
    demonstrateTypeAssertions()
    demonstrateErrorWrapping()
    demonstrateCustomErrors()
}

// 1. Function returning errors
func demonstrateFunctionErrors() {
    fmt.Println("=== Function Errors ===")

    // Success case
    if result, err := divide(10, 2); err == nil {
        fmt.Printf("10 / 2 = %.2f\n", result)
    } else {
        fmt.Printf("Error: %v\n", err)
    }

    // Error case
    if _, err := divide(10, 0); err != nil {
        fmt.Printf("Error: %v\n", err)
    }
    fmt.Println()
}

func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// 2. Map value checking
func demonstrateMapErrors() {
    fmt.Println("=== Map Value Checking ===")

    prices := map[string]float64{
        "AAPL": 150.25,
        "GOOGL": 2800.50,
        "MSFT": 300.75,
    }

    // Check existing key
    if price, ok := prices["AAPL"]; ok {
        fmt.Printf("AAPL: $%.2f ‚úì\n", price)
    } else {
        fmt.Println("AAPL: Not found ‚úó")
    }

    // Check non-existing key
    if price, ok := prices["TSLA"]; ok {
        fmt.Printf("TSLA: $%.2f ‚úì\n", price)
    } else {
        fmt.Printf("TSLA: Not found ‚úó (got zero value: %.2f)\n", price)
    }

    // Without comma-OK (risky!)
    price := prices["TSLA"]  // Returns 0.0 (zero value)
    fmt.Printf("TSLA without checking: $%.2f (could be actual or zero value!)\n", price)
    fmt.Println()
}

// 3. Type assertions
func demonstrateTypeAssertions() {
    fmt.Println("=== Type Assertions ===")

    var value any = "Hello, Go!"

    // Comma-OK pattern (safe)
    if str, ok := value.(string); ok {
        fmt.Printf("‚úì String: %s\n", str)
    } else {
        fmt.Println("‚úó Not a string")
    }

    if num, ok := value.(int); ok {
        fmt.Printf("‚úì Int: %d\n", num)
    } else {
        fmt.Println("‚úó Not an int")
    }

    // Type switch (best for multiple types)
    describeValue(42)
    describeValue("Hello")
    describeValue(3.14)
    describeValue(true)
    describeValue([]int{1, 2, 3})
    fmt.Println()
}

func describeValue(value any) {
    switch v := value.(type) {
    case int:
        fmt.Printf("Integer: %d\n", v)
    case string:
        fmt.Printf("String: %s\n", v)
    case float64:
        fmt.Printf("Float: %.2f\n", v)
    case bool:
        fmt.Printf("Boolean: %v\n", v)
    default:
        fmt.Printf("Unknown type: %T = %v\n", v, v)
    }
}

// 4. Error wrapping (Go 1.13+)
func demonstrateErrorWrapping() {
    fmt.Println("=== Error Wrapping ===")

    err := processFile("nonexistent.txt")
    if err != nil {
        fmt.Printf("Error: %v\n", err)

        // Check if it's a specific error
        if errors.Is(err, ErrFileNotFound) {
            fmt.Println("‚úì Detected: file not found error")
        }
    }
    fmt.Println()
}

var ErrFileNotFound = errors.New("file not found")

func processFile(filename string) error {
    err := openFile(filename)
    if err != nil {
        // Wrap error with context
        return fmt.Errorf("processFile failed: %w", err)
    }
    return nil
}

func openFile(filename string) error {
    // Simulate file not found
    return ErrFileNotFound
}

// 5. Custom error types
func demonstrateCustomErrors() {
    fmt.Println("=== Custom Errors ===")

    err := validateAge(-5)
    if err != nil {
        fmt.Printf("Error: %v\n", err)

        // Type assertion on custom error
        if validErr, ok := err.(*ValidationError); ok {
            fmt.Printf("Field: %s, Value: %v\n", validErr.Field, validErr.Value)
        }
    }

    err = validateAge(150)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
    }

    err = validateAge(25)
    if err == nil {
        fmt.Println("‚úì Valid age")
    }
}

type ValidationError struct {
    Field   string
    Value   interface{}
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on %s: %s (got: %v)",
        e.Field, e.Message, e.Value)
}

func validateAge(age int) error {
    if age < 0 {
        return &ValidationError{
            Field:   "age",
            Value:   age,
            Message: "cannot be negative",
        }
    }
    if age > 120 {
        return &ValidationError{
            Field:   "age",
            Value:   age,
            Message: "unrealistic value",
        }
    }
    return nil
}

/*
ERROR HANDLING PATTERNS:

1. FUNCTION ERRORS:
   func DoSomething() (result Type, err error)
   - Return error as last value
   - nil means success
   - Check with: if err != nil

2. MAP CHECKING:
   value, ok := map[key]
   - ok is false if key doesn't exist
   - value is zero-value if not found

3. TYPE ASSERTIONS:
   value, ok := interface{}.(Type)
   - ok is false if type doesn't match
   - Without ok: PANIC if wrong type!

4. TYPE SWITCH:
   switch v := value.(type) {
   case Type1: ...
   case Type2: ...
   }

5. ERROR WRAPPING (Go 1.13+):
   fmt.Errorf("context: %w", err)
   - %w preserves original error
   - Use errors.Is() to check
   - Use errors.As() for type assertion

6. CUSTOM ERRORS:
   type MyError struct { ... }
   func (e *MyError) Error() string { ... }

BEST PRACTICES:
‚úÖ Always check errors
‚úÖ Use comma-OK for safety
‚úÖ Wrap errors with context
‚úÖ Define sentinel errors (var ErrXxx = errors.New(...))
‚úÖ Use custom types for complex errors
‚ùå Don't ignore errors
‚ùå Don't panic in library code
‚ùå Don't use panic for control flow
*/
```

---

## Rating Breakdown

| Category      | Rating | Comments                              |
| ------------- | ------ | ------------------------------------- |
| Pattern Usage | 10/10  | Perfect comma-OK and type assertions! |
| Understanding | 9/10   | Deep grasp of error handling          |
| Code Quality  | 8/10   | Clean, minor spelling issues          |
| Examples      | 9/10   | Comprehensive demonstrations          |

**Overall: 8.5/10**

---

## Key Takeaways

1. ‚úÖ **Comma-OK pattern** prevents panics and provides safety
2. ‚úÖ **Function errors**: Return error as last value, nil = success
3. ‚úÖ **Map checking**: `value, ok := map[key]` handles missing keys
4. ‚úÖ **Type assertions**: `value, ok := any.(Type)` is safe
5. ‚úÖ **Type switch**: Better than multiple if-else for type checking
6. üéØ **Error wrapping**: Use `fmt.Errorf("context: %w", err)` (Go 1.13+)

---

## Next Steps

1. ‚úÖ Learn error wrapping with `%w`
2. ‚úÖ Practice `errors.Is()` and `errors.As()`
3. ‚úÖ Create custom error types
4. ‚úÖ Study panic/recover (for exceptional cases only)
5. ‚úÖ Learn sentinel errors pattern
6. ‚úÖ Practice defer for cleanup

**Excellent work! Your understanding of Go's error handling idioms is very strong. The detailed comments show you really get it!** ‚≠ê
