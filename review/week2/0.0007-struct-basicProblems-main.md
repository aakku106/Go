# Code Review: 0.0007/struct/basicProblems/main.go

## Overall Assessment

**File Purpose**: Practice problems - factorial and Fibonacci sequence  
**Rating**: 7.5/10  
**Status**: Good implementations, but can be improved!

---

## Detailed Review

### âœ… Strengths

1. **Recursive Solutions**: Implemented recursion correctly
2. **Good Practice**: Classic CS problems to practice functions
3. **Multiple Examples**: Both factorial and Fibonacci
4. **Clean Code**: Easy to read and understand

### âš ï¸ **ISSUES & IMPROVEMENTS**

#### Issue #1: Inefficient Fibonacci

```go
func fibonacci(n int) int {
    if n == 0 {
        return 0
    } else if n == 1 {
        return 1
    }
    return fibonacci(n-1) + fibonacci(n-2)
}
```

**Problem**: This has **exponential time complexity** O(2^n)!

**Why it's slow**:

```
fibonacci(5)
â”œâ”€ fibonacci(4)
â”‚  â”œâ”€ fibonacci(3)
â”‚  â”‚  â”œâ”€ fibonacci(2)
â”‚  â”‚  â”‚  â”œâ”€ fibonacci(1) â†’ 1
â”‚  â”‚  â”‚  â””â”€ fibonacci(0) â†’ 0
â”‚  â”‚  â””â”€ fibonacci(1) â†’ 1
â”‚  â””â”€ fibonacci(2)
â”‚     â”œâ”€ fibonacci(1) â†’ 1
â”‚     â””â”€ fibonacci(0) â†’ 0
â””â”€ fibonacci(3)
   â”œâ”€ fibonacci(2)
   â”‚  â”œâ”€ fibonacci(1) â†’ 1
   â”‚  â””â”€ fibonacci(0) â†’ 0
   â””â”€ fibonacci(1) â†’ 1
```

Notice: `fibonacci(3)` is calculated **twice**, `fibonacci(2)` **three times**!

**Better Solutions**:

**1. Memoization (cache results)**:

```go
func fibonacciMemo(n int, memo map[int]int) int {
    if n == 0 {
        return 0
    }
    if n == 1 {
        return 1
    }

    // Check cache
    if val, ok := memo[n]; ok {
        return val
    }

    // Calculate and cache
    result := fibonacciMemo(n-1, memo) + fibonacciMemo(n-2, memo)
    memo[n] = result
    return result
}

// Usage:
memo := make(map[int]int)
result := fibonacciMemo(50, memo)  // Fast!
```

**2. Iterative (most efficient)**:

```go
func fibonacciIterative(n int) int {
    if n == 0 {
        return 0
    }
    if n == 1 {
        return 1
    }

    prev, curr := 0, 1
    for i := 2; i <= n; i++ {
        prev, curr = curr, prev+curr
    }
    return curr
}
```

**Performance comparison**:

```
fibonacci(40) recursive:   ~2 seconds
fibonacci(40) memoized:    instant
fibonacci(40) iterative:   instant
```

#### Issue #2: Missing Edge Cases

```go
func factorial(n int) int {
    if n == 0 {
        return 1
    }
    return n * factorial(n-1)
}
```

**Problems**:

1. **Negative numbers**: `factorial(-5)` will crash (stack overflow)!
2. **Large numbers**: Overflow - `factorial(21)` overflows `int`
3. **No error handling**: Should return error for invalid input

**Better implementation**:

```go
func factorial(n int) (int, error) {
    if n < 0 {
        return 0, errors.New("factorial is not defined for negative numbers")
    }
    if n == 0 || n == 1 {
        return 1, nil
    }
    if n > 20 {
        return 0, errors.New("result would overflow int")
    }

    result, _ := factorial(n - 1)
    return n * result, nil
}
```

Or use `uint64` for larger range:

```go
func factorialBig(n uint64) uint64 {
    if n == 0 || n == 1 {
        return 1
    }
    return n * factorialBig(n-1)
}
// Can handle factorial(20) without overflow
```

#### Issue #3: No Comments

Your code has **zero comments**! Good code explains:

- What the function does
- Parameters and return values
- Edge cases
- Time/space complexity

**Example**:

```go
// factorial calculates n! (n factorial)
// Returns error for negative numbers or values that would overflow.
// Time complexity: O(n)
// Space complexity: O(n) due to call stack
func factorial(n int) (int, error) {
    // ...
}
```

### ğŸ“š Algorithm Deep Dive

#### Understanding Recursion

**Recursion requires**:

1. **Base case**: Where recursion stops
2. **Recursive case**: Function calls itself with simpler input
3. **Progress**: Each call must move toward base case

**Your factorial** (anatomy):

```go
func factorial(n int) int {
    if n == 0 {           // â† Base case
        return 1
    }
    return n * factorial(n-1)  // â† Recursive case (nâ†’n-1, progresses to 0)
}
```

**Execution trace** for `factorial(5)`:

```
factorial(5)
  â†’ 5 * factorial(4)
       â†’ 4 * factorial(3)
            â†’ 3 * factorial(2)
                 â†’ 2 * factorial(1)
                      â†’ 1 * factorial(0)
                           â†’ 1
                      â† 1 * 1 = 1
                 â† 2 * 1 = 2
            â† 3 * 2 = 6
       â† 4 * 6 = 24
  â† 5 * 24 = 120
```

#### Recursion vs Iteration

**When to use recursion**:

- Problem naturally recursive (tree traversal, divide-and-conquer)
- Code is much clearer than iterative version
- Stack depth is manageable

**When to use iteration**:

- Performance critical (avoid function call overhead)
- Large input (avoid stack overflow)
- Simple linear problem (factorial, Fibonacci)

**Example - both versions**:

```go
// Recursive factorial
func factorialRecursive(n int) int {
    if n == 0 {
        return 1
    }
    return n * factorialRecursive(n-1)
}

// Iterative factorial (more efficient!)
func factorialIterative(n int) int {
    result := 1
    for i := 2; i <= n; i++ {
        result *= i
    }
    return result
}
```

### ğŸ”§ Enhanced Solutions

```go
package main

import (
    "errors"
    "fmt"
    "math/big"
)

func main() {
    demonstrateFactorial()
    demonstrateFibonacci()
    demonstrateBigNumbers()
    demonstratePerformance()
}

// ===== FACTORIAL =====

// factorialRecursive calculates n! using recursion
// Time: O(n), Space: O(n) call stack
func factorialRecursive(n int) (int, error) {
    if n < 0 {
        return 0, errors.New("factorial undefined for negative numbers")
    }
    if n > 20 {
        return 0, errors.New("result would overflow int")
    }
    if n == 0 || n == 1 {
        return 1, nil
    }

    result, err := factorialRecursive(n - 1)
    if err != nil {
        return 0, err
    }
    return n * result, nil
}

// factorialIterative calculates n! using iteration
// Time: O(n), Space: O(1) - more efficient!
func factorialIterative(n int) (int, error) {
    if n < 0 {
        return 0, errors.New("factorial undefined for negative numbers")
    }
    if n > 20 {
        return 0, errors.New("result would overflow int")
    }

    result := 1
    for i := 2; i <= n; i++ {
        result *= i
    }
    return result, nil
}

// factorialBig handles very large factorials using big.Int
func factorialBig(n int) (*big.Int, error) {
    if n < 0 {
        return nil, errors.New("factorial undefined for negative numbers")
    }

    result := big.NewInt(1)
    for i := 2; i <= n; i++ {
        result.Mul(result, big.NewInt(int64(i)))
    }
    return result, nil
}

// ===== FIBONACCI =====

// fibonacciNaive - your implementation (exponential time!)
// Time: O(2^n), Space: O(n)
func fibonacciNaive(n int) int {
    if n == 0 {
        return 0
    }
    if n == 1 {
        return 1
    }
    return fibonacciNaive(n-1) + fibonacciNaive(n-2)
}

// fibonacciMemo - with memoization (much faster!)
// Time: O(n), Space: O(n)
func fibonacciMemo(n int, memo map[int]int) int {
    if n == 0 {
        return 0
    }
    if n == 1 {
        return 1
    }

    // Check cache
    if val, ok := memo[n]; ok {
        return val
    }

    // Calculate and cache
    result := fibonacciMemo(n-1, memo) + fibonacciMemo(n-2, memo)
    memo[n] = result
    return result
}

// fibonacciIterative - most efficient!
// Time: O(n), Space: O(1)
func fibonacciIterative(n int) int {
    if n == 0 {
        return 0
    }
    if n == 1 {
        return 1
    }

    prev, curr := 0, 1
    for i := 2; i <= n; i++ {
        prev, curr = curr, prev+curr
    }
    return curr
}

// fibonacciSequence returns first n Fibonacci numbers
func fibonacciSequence(n int) []int {
    if n <= 0 {
        return []int{}
    }
    if n == 1 {
        return []int{0}
    }

    seq := make([]int, n)
    seq[0], seq[1] = 0, 1
    for i := 2; i < n; i++ {
        seq[i] = seq[i-1] + seq[i-2]
    }
    return seq
}

// ===== DEMONSTRATIONS =====

func demonstrateFactorial() {
    fmt.Println("=== Factorial ===")

    // Valid cases
    for _, n := range []int{0, 1, 5, 10} {
        result, _ := factorialRecursive(n)
        fmt.Printf("%d! = %d\n", n, result)
    }

    // Compare recursive vs iterative
    n := 15
    rec, _ := factorialRecursive(n)
    iter, _ := factorialIterative(n)
    fmt.Printf("%d! recursive: %d, iterative: %d\n", n, rec, iter)

    // Error case
    if _, err := factorialRecursive(-5); err != nil {
        fmt.Printf("factorial(-5): %v\n", err)
    }

    fmt.Println()
}

func demonstrateFibonacci() {
    fmt.Println("=== Fibonacci ===")

    // Show sequence
    fmt.Println("First 15 Fibonacci numbers:")
    seq := fibonacciSequence(15)
    fmt.Println(seq)

    // Compare methods
    n := 10
    naive := fibonacciNaive(n)
    memo := fibonacciMemo(n, make(map[int]int))
    iter := fibonacciIterative(n)
    fmt.Printf("fibonacci(%d): naive=%d, memo=%d, iter=%d\n", n, naive, memo, iter)

    fmt.Println()
}

func demonstrateBigNumbers() {
    fmt.Println("=== Big Numbers ===")

    // Regular int overflows at 21!
    if _, err := factorialIterative(21); err != nil {
        fmt.Printf("21! with int: %v\n", err)
    }

    // But big.Int handles it!
    big21, _ := factorialBig(21)
    fmt.Printf("21! with big.Int: %s\n", big21.String())

    // Even bigger
    big100, _ := factorialBig(100)
    fmt.Printf("100! = %s\n", big100.String())

    fmt.Println()
}

func demonstratePerformance() {
    fmt.Println("=== Performance Comparison ===")

    // Small n - all methods work
    n := 20
    fmt.Printf("Fibonacci(%d):\n", n)

    // Don't run naive for large n! It's too slow
    // naive := fibonacciNaive(n)  // Would take forever for n=40!

    memo := fibonacciMemo(n, make(map[int]int))
    iter := fibonacciIterative(n)

    fmt.Printf("  Memoized: %d\n", memo)
    fmt.Printf("  Iterative: %d\n", iter)

    // Large n - only efficient methods
    n = 50
    fmt.Printf("\nFibonacci(%d):\n", n)
    memo50 := fibonacciMemo(n, make(map[int]int))
    iter50 := fibonacciIterative(n)
    fmt.Printf("  Memoized: %d\n", memo50)
    fmt.Printf("  Iterative: %d\n", iter50)
}

/*
ALGORITHM COMPLEXITY:

Factorial:
- Recursive: O(n) time, O(n) space (call stack)
- Iterative: O(n) time, O(1) space (better!)

Fibonacci:
- Naive recursive: O(2^n) time (exponential - very slow!)
- Memoized: O(n) time, O(n) space
- Iterative: O(n) time, O(1) space (best!)

WHEN TO USE RECURSION:
âœ… Tree/graph traversal
âœ… Divide and conquer (merge sort, quick sort)
âœ… Naturally recursive problems (directory listing)
âœ… When code clarity > performance

WHEN TO AVOID RECURSION:
âŒ Deep recursion (stack overflow risk)
âŒ Problems with repeated subproblems (use memoization or iteration)
âŒ Performance-critical code
âŒ Simple linear problems (factorial, Fibonacci)

BEST PRACTICES:
1. Always validate input
2. Handle edge cases (negative, zero, overflow)
3. Document complexity
4. Consider iterative alternative
5. Use memoization for recursive solutions with overlapping subproblems
6. Use big.Int for large numbers
*/
```

---

## Rating Breakdown

| Category       | Rating | Comments                              |
| -------------- | ------ | ------------------------------------- |
| Implementation | 8/10   | Correct but naive algorithms          |
| Edge Cases     | 5/10   | Missing validation and error handling |
| Efficiency     | 6/10   | Fibonacci is exponential time         |
| Documentation  | 4/10   | No comments at all                    |

**Overall: 7.5/10**

---

## Key Takeaways

1. ğŸš¨ **Naive Fibonacci is O(2^n)** - exponential and very slow!
2. âœ… **Memoization** makes recursion efficient
3. âœ… **Iterative** is often better than recursive for simple problems
4. âš ï¸ **Validate input**: Check for negative, overflow
5. âœ… **Use `big.Int`** for large numbers
6. ğŸ“ **Document**: Add comments explaining complexity and edge cases

---

## Next Steps

1. âœ… Implement iterative versions of both
2. âœ… Add memoization to Fibonacci
3. âœ… Add input validation and error handling
4. âœ… Learn about time/space complexity (Big O notation)
5. âœ… Practice more recursive problems (tree traversal, combinations)
6. âœ… Study dynamic programming (memoization + bottom-up)

**Good practice! You got the basics right. Now focus on efficiency, edge cases, and proper error handling.** ğŸ¯
