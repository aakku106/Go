# Code Review: 0.0007/struct/moreExample/main.go

## Overall Assessment

**File Purpose**: Learn interfaces through Shape polymorphism example  
**Rating**: 9/10  
**Status**: Excellent! You discovered polymorphism!

---

## Detailed Review

### ‚úÖ Strengths

1. **Perfect Discovery**: You understood interfaces and polymorphism!
2. **Great Example**: Shape interface is a classic and perfect use case
3. **Multiple Types**: Circle and Rectangle implementing same interface
4. **Practical Code**: Demonstrates real-world polymorphism
5. **Good Comments**: Explained what you discovered

### ‚ö†Ô∏è **MINOR ISSUES**

#### Issue #1: Spelling

```go
// "differet" ‚Üí "different"
```

#### Issue #2: Incomplete Comment

```go
// so what Interface do is it let you use differet Type without you specifying it
```

**Better explanation**:

- Interfaces define a **contract** (set of methods)
- Any type that implements those methods **automatically** satisfies the interface
- You can write functions that work with **any type** implementing the interface
- This is **polymorphism**: "many forms" - same interface, different implementations

#### Issue #3: Magic Numbers

```go
func main() {
    circle := Circle{5}
    rec := Rectangle{2, 4}
```

**Better**: Use descriptive variable names or comments:

```go
circle := Circle{radius: 5}  // radius = 5 units
rec := Rectangle{height: 2, width: 4}
```

### üìö Interface Deep Dive

#### What You Discovered (Perfect!)

**Discovery 1: Interface Definition**

```go
type Shape interface {
    area() int
    perimeter() int
}
```

‚úÖ **Correct!** Defines a contract: "anything with area() and perimeter() is a Shape"

**Discovery 2: Implicit Implementation**

```go
type Circle struct { radius int }
func (c Circle) area() int { ... }
func (c Circle) perimeter() int { ... }
// Circle is now a Shape! No "implements" keyword needed!
```

‚úÖ **Excellent!** Go uses **implicit** interface satisfaction (duck typing)

**Discovery 3: Polymorphism**

```go
func printData(s Shape) {
    fmt.Println("Area: ", s.area())
    fmt.Println("Perimeter: ", s.perimeter())
}

circle := Circle{5}
rec := Rectangle{2, 4}
printData(circle)     // Works!
printData(rec)        // Works!
```

‚úÖ **Perfect!** Same function works with different types!

### üéØ Interface Patterns

#### Empty Interface (interface{})

```go
// interface{} accepts ANY type
func printAnything(v interface{}) {
    fmt.Println(v)
}

printAnything(42)
printAnything("hello")
printAnything(Circle{5})
```

**Modern Go** (Go 1.18+):

```go
// Use 'any' instead of interface{}
func printAnything(v any) {
    fmt.Println(v)
}
```

#### Type Assertion

```go
func describe(s Shape) {
    // Type assertion: check if s is actually a Circle
    if circle, ok := s.(Circle); ok {
        fmt.Printf("Circle with radius %d\n", circle.radius)
    } else if rect, ok := s.(Rectangle); ok {
        fmt.Printf("Rectangle %dx%d\n", rect.height, rect.width)
    }
}
```

#### Type Switch

```go
func describeShape(s Shape) {
    switch v := s.(type) {
    case Circle:
        fmt.Printf("Circle, radius=%d\n", v.radius)
    case Rectangle:
        fmt.Printf("Rectangle, %dx%d\n", v.height, v.width)
    default:
        fmt.Println("Unknown shape")
    }
}
```

#### Interface Composition

```go
// Combine multiple interfaces
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

type ReadWriter interface {
    Reader  // Embeds Reader interface
    Writer  // Embeds Writer interface
}

// Any type with both Read() and Write() satisfies ReadWriter
```

#### Common Standard Interfaces

```go
// 1. Stringer (for custom string representation)
type Stringer interface {
    String() string
}

func (c Circle) String() string {
    return fmt.Sprintf("Circle(r=%d)", c.radius)
}

// 2. Error (for custom errors)
type error interface {
    Error() string
}

type MyError struct {
    msg string
}

func (e MyError) Error() string {
    return e.msg
}

// 3. Sort interface
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}
```

#### Accepting Interfaces, Returning Structs

**Go proverb**: _"Accept interfaces, return structs"_

```go
// ‚úÖ Good: Accept interface (flexible)
func calculateTotalArea(shapes []Shape) int {
    total := 0
    for _, s := range shapes {
        total += s.area()
    }
    return total
}

// ‚úÖ Good: Return concrete type (clear)
func NewCircle(radius int) Circle {
    return Circle{radius: radius}
}

// ‚ùå Avoid: Return interface (unless necessary)
func NewCircle(radius int) Shape {  // Don't do this
    return Circle{radius: radius}
}
```

### üîß Enhanced Complete Example

```go
package main

import (
    "fmt"
    "math"
)

// ===== INTERFACES =====

// Shape defines the contract for geometric shapes
type Shape interface {
    Area() float64
    Perimeter() float64
}

// Drawable adds rendering capability
type Drawable interface {
    Draw() string
}

// DrawableShape combines both interfaces
type DrawableShape interface {
    Shape
    Drawable
}

// ===== CIRCLE =====

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}

func (c Circle) Draw() string {
    return "‚≠ï Circle"
}

// Stringer interface
func (c Circle) String() string {
    return fmt.Sprintf("Circle(radius=%.2f)", c.Radius)
}

// ===== RECTANGLE =====

type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

func (r Rectangle) Draw() string {
    return "‚ñ≠ Rectangle"
}

func (r Rectangle) String() string {
    return fmt.Sprintf("Rectangle(%.2fx%.2f)", r.Width, r.Height)
}

// ===== TRIANGLE =====

type Triangle struct {
    Base   float64
    Height float64
    Side1  float64
    Side2  float64
}

func (t Triangle) Area() float64 {
    return 0.5 * t.Base * t.Height
}

func (t Triangle) Perimeter() float64 {
    return t.Base + t.Side1 + t.Side2
}

func (t Triangle) Draw() string {
    return "‚ñ≥ Triangle"
}

func (t Triangle) String() string {
    return fmt.Sprintf("Triangle(base=%.2f, height=%.2f)", t.Base, t.Height)
}

// ===== FUNCTIONS USING INTERFACES =====

// printShapeInfo works with ANY type implementing Shape
func printShapeInfo(s Shape) {
    fmt.Printf("Shape: %v\n", s)  // Uses String() if available
    fmt.Printf("  Area: %.2f\n", s.Area())
    fmt.Printf("  Perimeter: %.2f\n", s.Perimeter())
}

// printDrawable works with ANY type implementing Drawable
func printDrawable(d Drawable) {
    fmt.Println(d.Draw())
}

// printDrawableShape works with types implementing BOTH interfaces
func printDrawableShape(ds DrawableShape) {
    fmt.Println(ds.Draw())
    fmt.Printf("  Area: %.2f\n", ds.Area())
}

// calculateTotalArea demonstrates collection of different shapes
func calculateTotalArea(shapes []Shape) float64 {
    total := 0.0
    for _, s := range shapes {
        total += s.Area()
    }
    return total
}

// describeShape demonstrates type assertion
func describeShape(s Shape) {
    // Type assertion with comma-ok
    if circle, ok := s.(Circle); ok {
        fmt.Printf("  It's a circle with radius %.2f\n", circle.Radius)
    } else if rect, ok := s.(Rectangle); ok {
        fmt.Printf("  It's a rectangle %.2fx%.2f\n", rect.Width, rect.Height)
    } else if tri, ok := s.(Triangle); ok {
        fmt.Printf("  It's a triangle with base %.2f\n", tri.Base)
    }
}

// describeShapeSwitch demonstrates type switch
func describeShapeSwitch(s Shape) {
    switch v := s.(type) {
    case Circle:
        fmt.Printf("Circle with radius %.2f and area %.2f\n", v.Radius, v.Area())
    case Rectangle:
        fmt.Printf("Rectangle %.2fx%.2f with area %.2f\n", v.Width, v.Height, v.Area())
    case Triangle:
        fmt.Printf("Triangle with base %.2f and area %.2f\n", v.Base, v.Area())
    default:
        fmt.Println("Unknown shape type")
    }
}

// ===== DEMONSTRATIONS =====

func main() {
    demonstrateBasicPolymorphism()
    demonstrateInterfaceComposition()
    demonstrateTypeAssertion()
    demonstrateTypeSwitch()
    demonstrateCollections()
    demonstrateEmptyInterface()
}

func demonstrateBasicPolymorphism() {
    fmt.Println("=== Basic Polymorphism ===")

    circle := Circle{Radius: 5.0}
    rectangle := Rectangle{Width: 4.0, Height: 6.0}
    triangle := Triangle{Base: 3.0, Height: 4.0, Side1: 3.0, Side2: 5.0}

    // Same function works with different types!
    printShapeInfo(circle)
    printShapeInfo(rectangle)
    printShapeInfo(triangle)
    fmt.Println()
}

func demonstrateInterfaceComposition() {
    fmt.Println("=== Interface Composition ===")

    circle := Circle{Radius: 3.0}

    // Circle implements both Shape and Drawable
    // So it also implements DrawableShape!
    printDrawableShape(circle)
    fmt.Println()
}

func demonstrateTypeAssertion() {
    fmt.Println("=== Type Assertion ===")

    var s Shape

    s = Circle{Radius: 5.0}
    fmt.Println("Checking Circle:")
    describeShape(s)

    s = Rectangle{Width: 3.0, Height: 4.0}
    fmt.Println("Checking Rectangle:")
    describeShape(s)
    fmt.Println()
}

func demonstrateTypeSwitch() {
    fmt.Println("=== Type Switch ===")

    shapes := []Shape{
        Circle{Radius: 2.0},
        Rectangle{Width: 3.0, Height: 4.0},
        Triangle{Base: 5.0, Height: 6.0, Side1: 5.0, Side2: 7.0},
    }

    for _, s := range shapes {
        describeShapeSwitch(s)
    }
    fmt.Println()
}

func demonstrateCollections() {
    fmt.Println("=== Collections of Interfaces ===")

    // Slice of different types, all satisfying Shape interface
    shapes := []Shape{
        Circle{Radius: 5.0},
        Rectangle{Width: 3.0, Height: 4.0},
        Triangle{Base: 6.0, Height: 8.0, Side1: 6.0, Side2: 10.0},
        Circle{Radius: 3.0},
    }

    fmt.Println("All shapes:")
    for i, s := range shapes {
        fmt.Printf("%d. %v - Area: %.2f\n", i+1, s, s.Area())
    }

    total := calculateTotalArea(shapes)
    fmt.Printf("Total area: %.2f\n", total)
    fmt.Println()
}

func demonstrateEmptyInterface() {
    fmt.Println("=== Empty Interface ===")

    // interface{} (or 'any') accepts anything
    var anything any

    anything = 42
    fmt.Printf("Int: %v (type: %T)\n", anything, anything)

    anything = "hello"
    fmt.Printf("String: %v (type: %T)\n", anything, anything)

    anything = Circle{Radius: 5.0}
    fmt.Printf("Circle: %v (type: %T)\n", anything, anything)

    // To use it as Circle, need type assertion
    if circle, ok := anything.(Circle); ok {
        fmt.Printf("Area: %.2f\n", circle.Area())
    }
}

/*
INTERFACE RULES:

1. Definition:
   type InterfaceName interface {
       MethodName(params) returnType
   }

2. Implementation:
   - IMPLICIT: Just implement all methods
   - No "implements" keyword needed
   - Duck typing: "If it quacks like a duck..."

3. Empty Interface:
   - interface{} or 'any' (Go 1.18+)
   - Accepts any type
   - Need type assertion to use

4. Type Assertion:
   value, ok := interfaceVar.(ConcreteType)

5. Type Switch:
   switch v := interfaceVar.(type) {
   case Type1:
       // v is Type1
   case Type2:
       // v is Type2
   }

6. Composition:
   Interfaces can embed other interfaces

BEST PRACTICES:
‚úÖ Keep interfaces small (1-3 methods ideal)
‚úÖ "Accept interfaces, return structs"
‚úÖ Define interfaces where they're used, not with implementations
‚úÖ Name single-method interfaces with -er suffix (Reader, Writer, Stringer)
‚ùå Don't use empty interface unless necessary
‚ùå Don't create interfaces "just in case" - create when you have 2+ implementations

COMMON STANDARD INTERFACES:
- error: Error() string
- fmt.Stringer: String() string
- io.Reader: Read([]byte) (int, error)
- io.Writer: Write([]byte) (int, error)
- sort.Interface: Len(), Less(), Swap()
*/
```

---

## Rating Breakdown

| Category       | Rating | Comments                                      |
| -------------- | ------ | --------------------------------------------- |
| Understanding  | 10/10  | Perfect grasp of interfaces and polymorphism! |
| Implementation | 9/10   | Clean, correct implementation                 |
| Code Quality   | 8/10   | Good, minor improvements possible             |
| Discovery      | 10/10  | Figured it out on your own!                   |

**Overall: 9/10**

---

## Key Takeaways

1. ‚úÖ **Interfaces define contracts** (set of methods)
2. ‚úÖ **Implicit satisfaction** - no "implements" keyword
3. ‚úÖ **Polymorphism** - same interface, different implementations
4. ‚úÖ **Type assertions** - convert interface to concrete type
5. ‚úÖ **Type switch** - handle different types elegantly
6. üéØ **Small interfaces** - 1-3 methods is ideal
7. ‚úÖ **"Accept interfaces, return structs"** - Go proverb

---

## Next Steps

1. ‚úÖ Practice with empty interface and type assertions
2. ‚úÖ Implement standard interfaces (Stringer, Error)
3. ‚úÖ Learn interface composition (embedding)
4. ‚úÖ Study io.Reader and io.Writer patterns
5. ‚úÖ Practice "accept interfaces, return structs" principle
6. ‚úÖ Learn when NOT to use interfaces (don't over-abstract)

**Outstanding work! You discovered one of Go's most powerful features on your own. Your understanding of polymorphism is excellent!** üåü
