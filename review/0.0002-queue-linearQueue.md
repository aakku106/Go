# Code Review: 0.0002/queue/linearQueue.go

## Overall Assessment

**File Purpose**: Linear Queue (FIFO) implementation  
**Rating**: 8/10  
**Status**: Solid implementation with good function design

---

## Detailed Review

### âœ… Strengths

1. **Clean FIFO Implementation**: Correct queue behavior (First-In-First-Out)
2. **Good Function Naming**: Names clearly indicate purpose (mostly)
3. **Error Handling**: Returns boolean to indicate empty queue
4. **Separation of Concerns**: Helper functions for queue operations
5. **User Interaction**: Good prompts and feedback

### âš ï¸ Issues & Improvements

#### 1. **Naming Convention Issues**

```go
func EnqueIntoLinerQueue() int  // Typos: "Enque" + "Liner"
func DequFromLinerQueue()       // Typos: "Dequ" + "Liner"
```

**Should be**:

```go
func EnqueueIntoLinearQueue() int
func DequeueFromLinearQueue()
```

**Spelling errors**:

- "Enque" â†’ "Enqueue"
- "Liner" â†’ "Linear"
- "Dequ" â†’ "Dequeue"

#### 2. **Inconsistent Variable Names**

```go
func EnqueIntoLinerQueue() int {
    var valueToEnqueueInLinearQueuesTop int  // Way too long!
    // ...
}
```

**Better**:

```go
func EnqueueIntoLinearQueue() int {
    var value int
    fmt.Println("Enter value to enqueue:")
    fmt.Scan(&value)
    linearQueueStoragePlace = append(linearQueueStoragePlace, value)
    return value
}
```

#### 3. **Inefficient Dequeue Operation**

```go
func DequFromLinerQueue() (int, bool) {
    if isLinearQueueEmpty() {
        return 0, true
    }
    dequedValue := linearQueueStoragePlace[0]
    linearQueueStoragePlace = linearQueueStoragePlace[1:]  // âš ï¸ Creates new slice
    return dequedValue, false
}
```

**Issue**: `linearQueueStoragePlace[1:]` creates a new slice every time, but the underlying array keeps growing. This is fine for learning, but it's not memory-efficient.

**Better Approach** (for production):

```go
type LinearQueue struct {
    data  []int
    front int  // Track front index
}

func (q *LinearQueue) Dequeue() (int, error) {
    if q.IsEmpty() {
        return 0, errors.New("queue is empty")
    }
    value := q.data[q.front]
    q.front++

    // Periodically reset to reclaim memory
    if q.front > len(q.data)/2 {
        q.data = q.data[q.front:]
        q.front = 0
    }
    return value, nil
}
```

#### 4. **Return Value Inconsistency**

```go
func DequFromLinerQueue() (int, bool) {
    if isLinearQueueEmpty() {
        return 0, true  // true means "was empty"
    }
    // ...
    return dequedValue, false  // false means "not empty"
}
```

**Confusing**: The boolean meaning is backwards from Go conventions.

**Go Convention**: Return `(value, error)` or `(value, ok)`

- `ok = true` means SUCCESS
- `ok = false` means FAILURE

**Better**:

```go
func DequeueFromLinearQueue() (int, bool) {
    if isLinearQueueEmpty() {
        return 0, false  // false = not successful
    }
    value := linearQueueStoragePlace[0]
    linearQueueStoragePlace = linearQueueStoragePlace[1:]
    return value, true  // true = successful
}

// Usage:
if value, ok := DequeueFromLinearQueue(); ok {
    fmt.Printf("Dequeued: %d\n", value)
} else {
    fmt.Println("Queue is empty")
}
```

Or even better, use Go's error pattern:

```go
func DequeueFromLinearQueue() (int, error) {
    if isLinearQueueEmpty() {
        return 0, errors.New("queue is empty")
    }
    value := linearQueueStoragePlace[0]
    linearQueueStoragePlace = linearQueueStoragePlace[1:]
    return value, nil
}
```

#### 5. **Peek Function Prints Instead of Returns**

```go
func PeekIntoLinearQueue() {
    if isLinearQueueEmpty() {
        fmt.Println("The Linear Queue is Empty !!!")
    } else {
        fmt.Printf("----->\t%d\t<---- is next to come out\n", linearQueueStoragePlace[0])
    }
}
```

**Issue**: Function does printing, not just peeking. Mixing concerns.

**Better**: Separate data retrieval from presentation

```go
func PeekLinearQueue() (int, error) {
    if isLinearQueueEmpty() {
        return 0, errors.New("queue is empty")
    }
    return linearQueueStoragePlace[0], nil
}

// In linearQueue() function:
if value, err := PeekLinearQueue(); err != nil {
    fmt.Println("Error:", err)
} else {
    fmt.Printf("Next value: %d\n", value)
}
```

### ğŸ“š Good Practices You're Using

1. âœ… **Helper Functions**: `isLinearQueueEmpty()` is good abstraction
2. âœ… **Clear Output**: Good user feedback messages
3. âœ… **FIFO Behavior**: Correctly implements queue semantics
4. âœ… **Return Values**: Using return values to communicate results

### ğŸ¯ Best Practices to Adopt

#### 1. **Use Error Type Instead of Bool**

```go
var ErrQueueEmpty = errors.New("queue is empty")

func DequeueFromLinearQueue() (int, error) {
    if isLinearQueueEmpty() {
        return 0, ErrQueueEmpty
    }
    // ...
}
```

#### 2. **Struct-Based Design**

```go
type LinearQueue struct {
    data []int
}

func NewLinearQueue() *LinearQueue {
    return &LinearQueue{
        data: make([]int, 0),
    }
}

func (q *LinearQueue) Enqueue(value int) {
    q.data = append(q.data, value)
}

func (q *LinearQueue) Dequeue() (int, error) {
    if q.IsEmpty() {
        return 0, ErrQueueEmpty
    }
    value := q.data[0]
    q.data = q.data[1:]
    return value, nil
}

func (q *LinearQueue) Peek() (int, error) {
    if q.IsEmpty() {
        return 0, ErrQueueEmpty
    }
    return q.data[0], nil
}

func (q *LinearQueue) IsEmpty() bool {
    return len(q.data) == 0
}

func (q *LinearQueue) Size() int {
    return len(q.data)
}
```

#### 3. **Add Tests**

```go
// linearQueue_test.go
func TestLinearQueue(t *testing.T) {
    q := NewLinearQueue()

    // Test empty queue
    if !q.IsEmpty() {
        t.Error("New queue should be empty")
    }

    // Test enqueue
    q.Enqueue(10)
    q.Enqueue(20)
    q.Enqueue(30)

    if q.Size() != 3 {
        t.Errorf("Expected size 3, got %d", q.Size())
    }

    // Test peek
    if val, _ := q.Peek(); val != 10 {
        t.Errorf("Expected 10, got %d", val)
    }

    // Test dequeue
    if val, _ := q.Dequeue(); val != 10 {
        t.Errorf("Expected 10, got %d", val)
    }

    if q.Size() != 2 {
        t.Errorf("Expected size 2, got %d", q.Size())
    }
}
```

### ğŸ”§ Complete Refactored Example

```go
package queue

import (
    "errors"
    "fmt"
)

var (
    ErrQueueEmpty = errors.New("queue is empty")
    ErrQueueFull  = errors.New("queue is full")
)

// LinearQueue implements a simple FIFO queue
type LinearQueue struct {
    data []int
    maxSize int  // -1 for unlimited
}

// NewLinearQueue creates a new linear queue
func NewLinearQueue(maxSize int) *LinearQueue {
    return &LinearQueue{
        data: make([]int, 0),
        maxSize: maxSize,
    }
}

// Enqueue adds an element to the rear of the queue
func (q *LinearQueue) Enqueue(value int) error {
    if q.IsFull() {
        return ErrQueueFull
    }
    q.data = append(q.data, value)
    return nil
}

// Dequeue removes and returns the front element
func (q *LinearQueue) Dequeue() (int, error) {
    if q.IsEmpty() {
        return 0, ErrQueueEmpty
    }
    value := q.data[0]
    q.data = q.data[1:]
    return value, nil
}

// Peek returns the front element without removing it
func (q *LinearQueue) Peek() (int, error) {
    if q.IsEmpty() {
        return 0, ErrQueueEmpty
    }
    return q.data[0], nil
}

// IsEmpty checks if the queue is empty
func (q *LinearQueue) IsEmpty() bool {
    return len(q.data) == 0
}

// IsFull checks if the queue is full
func (q *LinearQueue) IsFull() bool {
    if q.maxSize < 0 {
        return false  // Unlimited size
    }
    return len(q.data) >= q.maxSize
}

// Size returns the number of elements in the queue
func (q *LinearQueue) Size() int {
    return len(q.data)
}

// Display prints the queue contents
func (q *LinearQueue) Display() {
    if q.IsEmpty() {
        fmt.Println("Queue is empty")
        return
    }
    fmt.Print("Front -> ")
    for i, val := range q.data {
        if i > 0 {
            fmt.Print(" <- ")
        }
        fmt.Print(val)
    }
    fmt.Println(" <- Rear")
}

// InteractiveMenu runs an interactive CLI for the queue
func (q *LinearQueue) InteractiveMenu() {
    for {
        fmt.Println("\n=== Linear Queue ===")
        fmt.Println("1. Enqueue")
        fmt.Println("2. Dequeue")
        fmt.Println("3. Peek")
        fmt.Println("4. Display")
        fmt.Println("5. Size")
        fmt.Println("0. Exit")
        fmt.Print("Choice: ")

        var choice int
        fmt.Scan(&choice)

        switch choice {
        case 0:
            return
        case 1:
            var value int
            fmt.Print("Enter value: ")
            fmt.Scan(&value)
            if err := q.Enqueue(value); err != nil {
                fmt.Println("Error:", err)
            } else {
                fmt.Printf("Enqueued %d\n", value)
            }
        case 2:
            if value, err := q.Dequeue(); err != nil {
                fmt.Println("Error:", err)
            } else {
                fmt.Printf("Dequeued %d\n", value)
            }
        case 3:
            if value, err := q.Peek(); err != nil {
                fmt.Println("Error:", err)
            } else {
                fmt.Printf("Front value: %d\n", value)
            }
        case 4:
            q.Display()
        case 5:
            fmt.Printf("Queue size: %d\n", q.Size())
        default:
            fmt.Println("Invalid choice")
        }
    }
}
```

---

## Rating Breakdown

| Category              | Rating | Comments                                 |
| --------------------- | ------ | ---------------------------------------- |
| Algorithm Correctness | 9/10   | FIFO behavior is correct                 |
| Code Quality          | 7/10   | Works well, naming issues                |
| Error Handling        | 7/10   | Good but uses bool instead of error      |
| Function Design       | 7/10   | Good separation, mixing concerns in Peek |
| Memory Efficiency     | 6/10   | Slice grows indefinitely                 |

**Overall: 8/10**

---

## Next Steps

1. âœ… Fix all spelling errors (Enque â†’ Enqueue, Liner â†’ Linear)
2. âœ… Use `error` return type instead of `bool`
3. âœ… Separate data operations from UI operations
4. âœ… Consider struct-based approach
5. âœ… Add unit tests
6. âœ… Learn about `container/list` in standard library

**Good implementation! You understand queues well. Now focus on Go idioms and best practices.**
