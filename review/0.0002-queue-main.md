# Code Review: 0.0002/queue/main.go

## Overall Assessment

**File Purpose**: Queue implementations (Linear, Circular, Priority)  
**Rating**: 7.5/10  
**Status**: Good structure, interactive menu system

---

## Detailed Review

### âœ… Strengths

1. **Good Architecture**: Separating queue types into different files
2. **Interactive Menu**: User-friendly menu system with clear options
3. **Constants Usage**: Using `iota` for menu options - excellent!
4. **Global State Management**: Using package-level variables to maintain queue state
5. **Modular Design**: Each queue type has its own file/function

### âš ï¸ Issues & Improvements

#### 1. **Typo in Constants**

```go
const (
    quit = iota  // 0
    linear       // 1
    circular     // 2
    prority      // 3 - TYPO!
)
```

**Should be**: `priority` (not "prority")

This typo appears throughout your codebase. Consistency matters!

#### 2. **Inconsistent Naming**

```go
var (
    linearQueueStoragePlace   []int      // Very long name
    circularQueueStoragePlace [5]int    // Very long name
    prorityQueueStoragePlace  [5][]int  // Typo + long name
)
```

**Better Names**:

```go
var (
    linearQueue   []int
    circularQueue [5]int
    priorityQueue [5][]int
)
```

The suffix "StoragePlace" is redundant - we know it stores data!

#### 3. **Magic Numbers**

```go
circularQueueStoragePlace [5]int
prorityQueueStoragePlace  [5][]int
```

**Better**: Use constants

```go
const (
    MaxQueueSize     = 5
    MaxPriorityLevel = 5
)

var (
    circularQueue [MaxQueueSize]int
    priorityQueue [MaxPriorityLevel][]int
)
```

#### 4. **Incomplete Menu Message**

```go
fmt.Println("Welci to queue, choose between")  // "Welci" â†’ "Welcome"
```

#### 5. **Mixed Concerns in Constants**

You have TWO `iota` blocks:

```go
const (
    quit = iota      // 0
    linear           // 1
    circular         // 2
    prority          // 3
)
const (
    enque = iota + 1 // 1
    deque            // 2
    peek             // 3
)
```

**Issue**: Both blocks define operations, but they're separate. This is okay, but naming could be clearer:

```go
// Queue types
const (
    QueueTypeExit = iota
    QueueTypeLinear
    QueueTypeCircular
    QueueTypePriority
)

// Queue operations
const (
    OpEnqueue = iota + 1
    OpDequeue
    OpPeek
)
```

#### 6. **Error Handling**

```go
var choose int8
fmt.Scan(&choose)
switch choose {
    // ...
    default:
        fmt.Println("Choose Between 1,2,3 or choose 0 to exit")
}
```

**Missing**: What if user enters non-numeric input? `fmt.Scan()` can fail.

**Better**:

```go
var choose int8
_, err := fmt.Scan(&choose)
if err != nil {
    fmt.Println("Invalid input! Please enter a number.")
    continue
}
```

### ðŸ“š Design Patterns You're Using

1. **Menu-Driven Interface**: Classic CLI pattern âœ…
2. **State Management**: Global variables for queue state
3. **Separation of Concerns**: Each queue type in separate file âœ…
4. **Constants for Enums**: Using `iota` âœ…

### ðŸŽ¯ Best Practices to Adopt

#### 1. **Input Validation Loop**

```go
func getMenuChoice(min, max int) int {
    for {
        var choice int
        _, err := fmt.Scan(&choice)
        if err != nil {
            fmt.Println("Invalid input! Please enter a number.")
            // Clear input buffer
            fmt.Scanln()
            continue
        }
        if choice >= min && choice <= max {
            return choice
        }
        fmt.Printf("Please choose between %d and %d\n", min, max)
    }
}
```

#### 2. **Clear Screen Function**

```go
func clearScreen() {
    fmt.Print("\033[H\033[2J")
}
```

#### 3. **DRY (Don't Repeat Yourself)**

Your menu printing is repetitive. Consider:

```go
func printMainMenu() {
    fmt.Println("\n=== Queue Management System ===")
    fmt.Println("0. Exit")
    fmt.Println("1. Linear Queue")
    fmt.Println("2. Circular Queue")
    fmt.Println("3. Priority Queue")
    fmt.Print("Choice: ")
}

func printOperationMenu() {
    fmt.Println("\n--- Operations ---")
    fmt.Println("1. Enqueue")
    fmt.Println("2. Dequeue")
    fmt.Println("3. Peek")
    fmt.Println("-1. Back")
    fmt.Print("Choice: ")
}
```

### ðŸ”§ Recommended Refactor

```go
package main

import (
    "fmt"
)

// Queue types
const (
    QueueExit = iota
    QueueLinear
    QueueCircular
    QueuePriority
)

// Operations
const (
    OpBack = -1
    OpExit = 0
    OpEnqueue = 1
    OpDequeue = 2
    OpPeek = 3
)

// Queue configuration
const (
    MaxQueueSize     = 5
    MaxPriorityLevel = 5
)

// Global queue storage
var (
    linearQueue   []int
    circularQueue [MaxQueueSize]int
    priorityQueue [MaxPriorityLevel][]int
)

func main() {
    fmt.Println("=== Queue Data Structure Demo ===")

    for {
        printMainMenu()

        choice := getIntInput()

        switch choice {
        case QueueExit:
            fmt.Println("Exiting... Goodbye!")
            return
        case QueueLinear:
            handleLinearQueue()
        case QueueCircular:
            handleCircularQueue()
        case QueuePriority:
            handlePriorityQueue()
        default:
            fmt.Println("Invalid choice! Please choose 0-3")
        }
    }
}

func printMainMenu() {
    fmt.Println("\n" + strings.Repeat("-", 40))
    fmt.Println("Choose a queue type:")
    fmt.Println("0. Exit")
    fmt.Println("1. Linear Queue")
    fmt.Println("2. Circular Queue")
    fmt.Println("3. Priority Queue")
    fmt.Print("Your choice: ")
}

func printOperationMenu() {
    fmt.Println("\nOperations:")
    fmt.Println("1. Enqueue")
    fmt.Println("2. Dequeue")
    fmt.Println("3. Peek")
    fmt.Println("-1. Back to main menu")
    fmt.Println("0. Exit program")
    fmt.Print("Your choice: ")
}

func getIntInput() int {
    var input int
    _, err := fmt.Scan(&input)
    if err != nil {
        fmt.Println("Invalid input! Please enter a number.")
        // Clear input buffer
        var discard string
        fmt.Scanln(&discard)
        return -1
    }
    return input
}

// Individual queue handlers would be in separate files
// linearQueue.go, circularQueue.go, priorityQueue.go
```

### ðŸŽ“ Advanced Topics to Explore

1. **Interfaces**: Create a `Queue` interface that all queue types implement

   ```go
   type Queue interface {
       Enqueue(value int) error
       Dequeue() (int, error)
       Peek() (int, error)
       IsEmpty() bool
       IsFull() bool
   }
   ```

2. **Struct-Based Queues**: Instead of global variables

   ```go
   type LinearQueue struct {
       data []int
   }

   func (q *LinearQueue) Enqueue(value int) {
       q.data = append(q.data, value)
   }
   ```

3. **Generics** (Go 1.18+): Make queues work with any type

   ```go
   type Queue[T any] struct {
       data []T
   }
   ```

4. **Testing**: Write unit tests for each queue operation

---

## Rating Breakdown

| Category        | Rating | Comments                              |
| --------------- | ------ | ------------------------------------- |
| Architecture    | 8/10   | Good separation, could use interfaces |
| Code Quality    | 7/10   | Clean but has typos and long names    |
| User Experience | 8/10   | Good menu system                      |
| Error Handling  | 5/10   | Missing input validation              |
| Constants Usage | 8/10   | Good use of iota                      |

**Overall: 7.5/10**

---

## Next Steps

1. âœ… Fix "prority" â†’ "priority" throughout codebase
2. âœ… Add input validation with error handling
3. âœ… Create constants for magic numbers
4. âœ… Consider using structs instead of global variables
5. âœ… Learn about interfaces
6. âœ… Add unit tests

**Good job on the modular structure! This is a solid foundation for learning data structures in Go.**
