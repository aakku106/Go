# Code Review: 0.0002/queue/prorityQueue.go

## Overall Assessment

**File Purpose**: Priority Queue implementation  
**Rating**: 7/10  
**Status**: Creative array-based approach, some issues

---

## Detailed Review

### ‚úÖ Strengths

1. **Creative Design**: Using array of slices `[5][]int` is clever!
2. **Priority Levels**: Good use of 0-4 priority system
3. **Linear Search**: Correct iteration through priorities
4. **Input Validation**: Using `goto` for re-input (unconventional but works)
5. **Good Comments**: Excellent planning notes at the bottom!

### üêõ **CRITICAL BUGS**

#### Bug #1: Goto Label Handling

```go
func EnqueueInProrityQueue() (int, int8, bool) {
a:  // ‚ö†Ô∏è This label is fine
    fmt.Println("Enter the value...")
    var (
        value   int
        prority int8
    )
    fmt.Scanf("%d,%d", &value, &prority)
    if prority >= 5 || prority < 0 {
        fmt.Println("choose Between 0,1,2,3,4")
        goto a  // This works, but...
    }
    // ...
}
```

**Issue**: Using `goto` is generally discouraged in Go. While it works here, it's better to use a loop.

**Better**:

```go
func EnqueueInPriorityQueue() (int, int8, error) {
    for {
        fmt.Println("Enter the value to Enqueue (format: value,priority)")
        fmt.Println("Priority: 0-4 (0 = highest priority)")

        var value int
        var priority int8
        _, err := fmt.Scanf("%d,%d", &value, &priority)

        if err != nil {
            fmt.Println("Invalid format! Use: value,priority")
            continue
        }

        if priority < 0 || priority >= 5 {
            fmt.Println("Priority must be between 0 and 4")
            continue
        }

        prorityQueueStoragePlace[priority] = append(prorityQueueStoragePlace[priority], value)
        return value, priority, nil
    }
}
```

#### Bug #2: Commented Out Code

```go
//	switch prority {
//	case 0:
//		prorityQueueStoragePlace[0] = append(prorityQueueStoragePlace[0], value)
//	case 1:
//		prorityQueueStoragePlace[1] = append(prorityQueueStoragePlace[1], value)
//	// ... etc
```

**Issue**: You replaced this with the cleaner line:

```go
prorityQueueStoragePlace[prority] = append(prorityQueueStoragePlace[prority], value)
```

**Good!** But remove the commented code. Your array index approach is much better than a switch!

#### Bug #3: Spelling Consistency

Throughout your entire codebase:

- "prority" ‚ùå
- "priority" ‚úÖ

This typo is everywhere! Variable names, function names, comments.

### ‚ö†Ô∏è Issues & Improvements

#### 1. **isEmpty() Bug**

```go
func isProrityQueueEmpty() bool {
    if (len(prorityQueueStoragePlace[0]) + len(prorityQueueStoragePlace[1]) + len(prorityQueueStoragePlace[2]) + len(prorityQueueStoragePlace[3]) + len(prorityQueueStoragePlace[4])) <= 0 {
        return true
    }
    return false
}
```

**Issues**:

1. Very long line (hard to read)
2. Can be simplified
3. Length can never be negative, so `<= 0` is same as `== 0`

**Better**:

```go
func isPriorityQueueEmpty() bool {
    for i := range prorityQueueStoragePlace {
        if len(prorityQueueStoragePlace[i]) > 0 {
            return false
        }
    }
    return true
}

// Or even simpler:
func isPriorityQueueEmpty() bool {
    for _, queue := range prorityQueueStoragePlace {
        if len(queue) > 0 {
            return false
        }
    }
    return true
}
```

#### 2. **Return Value Confusion**

```go
func EnqueueInProrityQueue() (int, int8, bool) {
    // ...
    return value, prority, true  // Success
}
```

But there's no failure case! The function always returns `true`.

**Better**: Remove the boolean or actually use it:

```go
func EnqueueInPriorityQueue() (int, int8, error) {
    // ... validation ...
    return value, priority, nil
}
```

#### 3. **Typo in Output**

```go
fmt.Printf("-->\t%d\t<--- will be cumming next with prority:\t%d", ...)
```

**Issues**:

- "cumming" ‚Üí "coming" üôà
- "prority" ‚Üí "priority"

#### 4. **Magic Number 5**

```go
for i := range 5 {  // 5 is hardcoded
```

**Better**:

```go
const MaxPriorityLevel = 5

var prorityQueueStoragePlace [MaxPriorityLevel][]int

for i := range MaxPriorityLevel {
    // ...
}
```

### üìö Your Design Analysis (from comments)

Your planning comments are **excellent**! Let's review your thinking:

> "i have 2 ideas to implement this prorityQueue
>
> 1. make 2 array, one to store value and another to store prority.
> 2. make 5 array, 0,1,2,3,4 and store value in respective prority arrays"

**Your Analysis**: ‚úÖ Correct!

- Option 1 would require sorting: O(n log n) or O(n¬≤)
- Option 2 (your choice): O(1) enqueue, O(k) dequeue where k = priority levels

**You made the right choice!**

> "way 1 all array or rather say slice are store in random place in memory, and in way 2 they are stored continously"

**Mostly correct!** Arrays of slices ARE contiguous in memory, but each slice's underlying array might not be. Still, your intuition about cache locality is good!

### üéØ Best Practices

#### 1. **Use Min-Heap for True Priority Queue**

Your approach works for fixed, small priority levels. For general priority queues, use a heap:

```go
import "container/heap"

type PriorityQueue []Item

type Item struct {
    value    int
    priority int
    index    int
}

// Implement heap.Interface methods
func (pq PriorityQueue) Len() int { return len(pq) }
func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].priority < pq[j].priority
}
func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
    pq[i].index = i
    pq[j].index = j
}
// ... Push, Pop methods
```

#### 2. **Struct-Based Design**

```go
type PriorityQueue struct {
    queues [5][]int  // 5 priority levels
}

func NewPriorityQueue() *PriorityQueue {
    return &PriorityQueue{}
}

func (pq *PriorityQueue) Enqueue(value int, priority int) error {
    if priority < 0 || priority >= len(pq.queues) {
        return fmt.Errorf("priority must be between 0 and %d", len(pq.queues)-1)
    }
    pq.queues[priority] = append(pq.queues[priority], value)
    return nil
}

func (pq *PriorityQueue) Dequeue() (int, int, error) {
    for priority := range pq.queues {
        if len(pq.queues[priority]) > 0 {
            value := pq.queues[priority][0]
            pq.queues[priority] = pq.queues[priority][1:]
            return value, priority, nil
        }
    }
    return 0, 0, errors.New("queue is empty")
}

func (pq *PriorityQueue) Peek() (int, int, error) {
    for priority := range pq.queues {
        if len(pq.queues[priority]) > 0 {
            return pq.queues[priority][0], priority, nil
        }
    }
    return 0, 0, errors.New("queue is empty")
}

func (pq *PriorityQueue) IsEmpty() bool {
    for _, queue := range pq.queues {
        if len(queue) > 0 {
            return false
        }
    }
    return true
}
```

### üîß Complete Refactor

```go
package queue

import (
    "errors"
    "fmt"
)

const MaxPriorityLevels = 5

var ErrQueueEmpty = errors.New("queue is empty")

// PriorityQueue using bucket approach (your clever design!)
type PriorityQueue struct {
    buckets [MaxPriorityLevels][]int
}

func NewPriorityQueue() *PriorityQueue {
    return &PriorityQueue{}
}

func (pq *PriorityQueue) Enqueue(value int, priority int) error {
    if priority < 0 || priority >= MaxPriorityLevels {
        return fmt.Errorf("priority must be 0-%d (0=highest)", MaxPriorityLevels-1)
    }
    pq.buckets[priority] = append(pq.buckets[priority], value)
    return nil
}

func (pq *PriorityQueue) Dequeue() (value int, priority int, err error) {
    for p := range pq.buckets {
        if len(pq.buckets[p]) > 0 {
            value = pq.buckets[p][0]
            pq.buckets[p] = pq.buckets[p][1:]
            return value, p, nil
        }
    }
    return 0, 0, ErrQueueEmpty
}

func (pq *PriorityQueue) Peek() (value int, priority int, err error) {
    for p := range pq.buckets {
        if len(pq.buckets[p]) > 0 {
            return pq.buckets[p][0], p, nil
        }
    }
    return 0, 0, ErrQueueEmpty
}

func (pq *PriorityQueue) IsEmpty() bool {
    for _, bucket := range pq.buckets {
        if len(bucket) > 0 {
            return false
        }
    }
    return true
}

func (pq *PriorityQueue) Size() int {
    total := 0
    for _, bucket := range pq.buckets {
        total += len(bucket)
    }
    return total
}

func (pq *PriorityQueue) Display() {
    if pq.IsEmpty() {
        fmt.Println("Priority Queue is empty")
        return
    }

    fmt.Println("Priority Queue contents:")
    for p, bucket := range pq.buckets {
        if len(bucket) > 0 {
            fmt.Printf("  Priority %d: %v\n", p, bucket)
        }
    }
}

func (pq *PriorityQueue) InteractiveMenu() {
    for {
        fmt.Println("\n=== Priority Queue ===")
        fmt.Println("1. Enqueue")
        fmt.Println("2. Dequeue")
        fmt.Println("3. Peek")
        fmt.Println("4. Display")
        fmt.Println("0. Back")
        fmt.Print("Choice: ")

        var choice int
        fmt.Scan(&choice)

        switch choice {
        case 0:
            return
        case 1:
            var value int
            var priority int
            fmt.Print("Enter value,priority (0=highest): ")
            _, err := fmt.Scanf("%d,%d", &value, &priority)
            if err != nil {
                fmt.Println("Invalid format! Use: value,priority")
                continue
            }
            if err := pq.Enqueue(value, priority); err != nil {
                fmt.Println("‚ùå", err)
            } else {
                fmt.Printf("‚úì Enqueued %d with priority %d\n", value, priority)
            }
        case 2:
            if value, priority, err := pq.Dequeue(); err != nil {
                fmt.Println("‚ùå", err)
            } else {
                fmt.Printf("‚úì Dequeued %d (priority %d)\n", value, priority)
            }
        case 3:
            if value, priority, err := pq.Peek(); err != nil {
                fmt.Println("‚ùå", err)
            } else {
                fmt.Printf("Next: %d (priority %d)\n", value, priority)
            }
        case 4:
            pq.Display()
        default:
            fmt.Println("Invalid choice")
        }
    }
}
```

---

## Rating Breakdown

| Category         | Rating | Comments                              |
| ---------------- | ------ | ------------------------------------- |
| Algorithm Design | 8/10   | Creative bucket approach!             |
| Code Quality     | 6/10   | Works but has typos and goto          |
| Understanding    | 8/10   | Your analysis is excellent!           |
| Time Complexity  | 9/10   | Efficient: O(1) enqueue, O(k) dequeue |
| Space Complexity | 8/10   | Good for fixed priorities             |

**Overall: 7/10**

---

## Key Insights

1. ‚úÖ **Your design choice was smart!** Bucket-based for fixed priorities
2. üéØ **Great problem analysis** in your comments
3. ‚ö†Ô∏è **Fix "prority" ‚Üí "priority"** everywhere
4. ‚ö†Ô∏è Replace `goto` with loops
5. ‚ö†Ô∏è Use error returns instead of booleans
6. üìö For general priority queues, learn about heaps

**Your approach shows good algorithm thinking! You're making smart trade-off decisions.**
