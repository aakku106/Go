# Code Review: 0.0013/generics.go

## Overall Assessment

**File Purpose**: Placeholder for generics learning  
**Rating**: N/A (Not Implemented)  
**Status**: Empty placeholder file

---

## File Contents

```go
package generics

func First() {

}
```

**This is just a placeholder.** The file structure exists but no implementation yet.

---

## ğŸ“š What Generics Are For

### Go 1.18+ Generics

Generics allow writing functions and types that work with any type:

```go
// Without generics (your current stack):
type Stack struct {
    stack []any  // Can hold any type, but loses type safety
}

// With generics (Go 1.18+):
type Stack[T any] struct {
    stack []T  // Type-safe for specific type
}

// Usage:
var intStack = Stack[int]{}    // Only ints
var strStack = Stack[string]{} // Only strings
```

---

## ğŸ¯ Generics Examples for Your Learning

### 1. Generic Stack (Type-Safe)

```go
package generics

type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    if len(s.items) == 0 {
        var zero T  // Zero value of type T
        return zero, false
    }

    index := len(s.items) - 1
    item := s.items[index]
    s.items = s.items[:index]
    return item, true
}

// Usage:
func main() {
    intStack := Stack[int]{}
    intStack.Push(1)
    intStack.Push(2)
    // intStack.Push("string")  // âŒ Compile error!

    val, ok := intStack.Pop()  // val is int, not any!
}
```

### 2. Generic Min Function

```go
package generics

type Ordered interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |
    ~float32 | ~float64 | ~string
}

func Min[T Ordered](a, b T) T {
    if a < b {
        return a
    }
    return b
}

// Usage:
func main() {
    fmt.Println(Min(3, 5))           // 3
    fmt.Println(Min(3.14, 2.71))     // 2.71
    fmt.Println(Min("apple", "zebra")) // "apple"
}
```

### 3. Generic Map Function

```go
func Map[T any, U any](slice []T, fn func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

// Usage:
nums := []int{1, 2, 3, 4}
doubled := Map(nums, func(n int) int { return n * 2 })
// doubled = [2, 4, 6, 8]

strs := Map(nums, func(n int) string { return fmt.Sprintf("%d", n) })
// strs = ["1", "2", "3", "4"]
```

### 4. Generic Queue

```go
type Queue[T any] struct {
    items []T
    front uint
    rear  uint
}

func (q *Queue[T]) Enqueue(item T) {
    q.items = append(q.items, item)
    q.rear++
}

func (q *Queue[T]) Dequeue() (T, bool) {
    if q.front == q.rear {
        var zero T
        return zero, false
    }

    item := q.items[q.front]
    q.front++

    // Self-healing (like yours!)
    if q.front == q.rear {
        q.front, q.rear = 0, 0
    }

    return item, true
}
```

---

## ğŸ“ Learning Path for Generics

### Week 1: Basic Generics

```go
// 1. Generic function
func Print[T any](value T) {
    fmt.Println(value)
}

// 2. Generic slice operation
func First[T any](slice []T) (T, bool) {
    if len(slice) == 0 {
        var zero T
        return zero, false
    }
    return slice[0], true
}

// 3. Generic struct
type Box[T any] struct {
    value T
}
```

### Week 2: Constraints

```go
// Numeric constraint
type Number interface {
    ~int | ~float64
}

func Add[T Number](a, b T) T {
    return a + b
}

// Comparable constraint
func Contains[T comparable](slice []T, val T) bool {
    for _, item := range slice {
        if item == val {
            return true
        }
    }
    return false
}
```

### Week 3: Advanced

```go
// Multiple type parameters
func Zip[T any, U any](slice1 []T, slice2 []U) []struct{a T; b U} {
    length := min(len(slice1), len(slice2))
    result := make([]struct{a T; b U}, length)
    for i := 0; i < length; i++ {
        result[i] = struct{a T; b U}{slice1[i], slice2[i]}
    }
    return result
}

// Generic methods
type Pair[T any, U any] struct {
    First  T
    Second U
}

func (p Pair[T, U]) Swap() Pair[U, T] {
    return Pair[U, T]{p.Second, p.First}
}
```

---

## ğŸš€ Next Steps

1. Implement `First()` function that returns first element of a slice
2. Create generic Stack[T] based on your existing Stack
3. Create generic Queue[T] based on your existing Queue
4. Test that type safety works (compile errors for wrong types)
5. Benchmark generic vs interface{}/any versions

---

## ğŸ“Š Comparison: any vs Generics

### Your Current Stack (using any)

```go
type Stack struct {
    stack []any
}

func (s *Stack) Push(value any) {
    s.stack = append(s.stack, value)
}

func (s *Stack) Pop() (any, bool) {
    // ...
    return s.stack[index], true
}

// Usage:
var stack = Stack{}
stack.Push(1)
stack.Push("string")  // âœ… Works
val, _ := stack.Pop()
num := val.(int)  // âŒ Runtime panic if wrong type!
```

### With Generics

```go
type Stack[T any] struct {
    stack []T
}

func (s *Stack[T]) Push(value T) {
    s.stack = append(s.stack, value)
}

func (s *Stack[T]) Pop() (T, bool) {
    // ...
    return s.stack[index], true
}

// Usage:
var stack = Stack[int]{}
stack.Push(1)
stack.Push("string")  // âŒ Compile error!
val, _ := stack.Pop()
// val is int, no cast needed!
```

**Benefits**:

- Compile-time type safety
- No type assertions needed
- Better performance (no interface overhead)
- Self-documenting code

---

## ğŸ¯ Recommended Implementation

```go
package generics

// First returns the first element of a slice
func First[T any](slice []T) (T, bool) {
    if len(slice) == 0 {
        var zero T  // Zero value of type T
        return zero, false
    }
    return slice[0], true
}

// Last returns the last element of a slice
func Last[T any](slice []T) (T, bool) {
    if len(slice) == 0 {
        var zero T
        return zero, false
    }
    return slice[len(slice)-1], true
}

// Filter returns a new slice containing only elements that match the predicate
func Filter[T any](slice []T, predicate func(T) bool) []T {
    result := []T{}
    for _, item := range slice {
        if predicate(item) {
            result = append(result, item)
        }
    }
    return result
}

// Map transforms each element using the provided function
func Map[T any, U any](slice []T, fn func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

// Reduce combines all elements using the provided function
func Reduce[T any, U any](slice []T, initial U, fn func(U, T) U) U {
    result := initial
    for _, item := range slice {
        result = fn(result, item)
    }
    return result
}
```

---

## Summary

**Current Status**: Empty placeholder  
**Recommendation**: Implement generic utility functions and migrate your Stack/Queue to generic versions  
**Learning Value**: High - generics are the future of Go type-safe code  
**Next File**: Create `generics_test.go` to test your implementations

---

_File reviewed: 0.0013/generics.go_  
_Status: Placeholder only_  
_Recommendation: Implement generic data structures_  
_Priority: Medium (good learning opportunity)_
