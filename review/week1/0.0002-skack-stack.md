# Code Review: 0.0002/skack/main.go & stack.go

## Overall Assessment

**File Purpose**: Stack (LIFO) implementation  
**Rating**: 7/10  
**Status**: Clean implementation, folder name typo!

---

## üö® **CRITICAL: Folder Name Typo**

```
skack/  ‚ùå
stack/  ‚úÖ
```

Your folder is named "skack" instead of "stack"! This is a significant typo that should be fixed.

---

## Review: main.go

### ‚úÖ Strengths

1. **Minimal main()**: Calls stack function - good separation
2. **Global state**: Using package variable `arr` (simple approach)

### ‚ö†Ô∏è Issues

```go
var arr []int

func main() {
    stack()
}
```

**Issues**:

1. Variable name `arr` is too generic
2. No initialization or comments
3. Empty main function (just calls stack)

**Better**:

```go
package main

var stackData []int  // Global stack storage

func main() {
    runStackDemo()
}
```

---

## Review: stack.go

### ‚úÖ Strengths

1. **Clean Stack Logic**: Correct LIFO (Last-In-First-Out) implementation
2. **Good Function Names**: Clear purpose for each function
3. **Error Handling**: Returns boolean for empty stack check
4. **Constants for Menu**: Using `iota` for menu options ‚úÖ

### üêõ **BUGS & ISSUES**

#### Bug #1: Function Return Type

```go
func stack() int {  // ‚ö†Ô∏è Returns int but...
    for {
        // ...
        switch choose {
        case exit:
            return 0  // Only return here
        // ... other cases don't return
        }
    }
}
```

**Issue**: Function returns `int` but it's never used. Should be `void` or return different values for different outcomes.

**Better**:

```go
func stack() {  // No return value needed
    for {
        // ...
        if shouldExit {
            return  // Just return
        }
    }
}
```

#### Bug #2: Missing Newlines in Output

```go
fmt.Printf("--->\t%d\tInserted in stack", InsertInStack())
```

**Issue**: No newline! Output will be messy.

**Better**:

```go
fmt.Printf("--->\t%d\tInserted in stack\n", InsertInStack())
```

#### Bug #3: Confusing Return Values

```go
func RemoveFromStack() (int, bool) {
    if !isStackEmpty() {
        // ...
        return lastIndexValue, true  // true = success
    }
    return 0, false  // false = failure
}

// But then you use it backwards:
tempPopedValue, isStackNotEmpty := RemoveFromStack()
if isStackNotEmpty {  // Variable name suggests opposite meaning!
    fmt.Printf("\t%d\tpoped from stack", tempPopedValue)
}
```

**Issue**: Variable is named `isStackNotEmpty` but the boolean means "was operation successful", not "is stack not empty".

**Better**:

```go
func RemoveFromStack() (int, error) {
    if isStackEmpty() {
        return 0, errors.New("stack is empty")
    }
    lastIndexValue := arr[len(arr)-1]
    arr = arr[:len(arr)-1]
    return lastIndexValue, nil
}

// Usage:
if value, err := RemoveFromStack(); err != nil {
    fmt.Println("Error:", err)
} else {
    fmt.Printf("Popped %d from stack\n", value)
}
```

#### Bug #4: Spelling Errors

```go
func RemoveFromStack() (int, bool) {
    // ...
}

// Later:
tempPopedValue  // "Poped" ‚Üí "Popped"
```

- "poped" ‚Üí "popped"
- "ot" ‚Üí "to" (in comment: "number ot put on stack")

#### Bug #5: Confusing Comment

```go
// Go people say it's to remove ambiguity,but i say i am more confused now xd
```

**Context**: This refers to Go not having `++` and `--` as expressions (only statements).

**What you might be referring to**:

```go
// This is VALID in C but NOT in Go:
int x = arr[i++];  // ‚ùå Can't do this in Go

// In Go you must do:
value := arr[i]    // ‚úÖ
i++                // ‚úÖ
```

**Why Go does this**: To avoid confusion like `x = i++` vs `x = ++i` (post vs pre increment)

### ‚ö†Ô∏è Minor Issues

#### 1. **Magic Numbers**

```go
case exit:      // 0
case insert:    // 1
case remove:    // 2
case peek:      // 3
```

These work fine with iota, but could be more explicit in usage.

#### 2. **Commented Debug Code**

```go
// fmt.Printf("\t%d\t%v\t", len(arr), arr)
//	fmt.Printf("\t%d\t%v\t", len(arr), arr)
```

Remove commented debug code from final version.

#### 3. **Input Validation**

```go
choose := -1
fmt.Scan(&choose)
```

No error handling for invalid input (like entering text instead of number).

### üìö Stack Implementation Analysis

Your stack implementation is **fundamentally correct**:

1. ‚úÖ **LIFO**: Last element added is first removed
2. ‚úÖ **Push**: Uses `append()` - O(1) amortized
3. ‚úÖ **Pop**: Uses slicing `[:len-1]` - O(1)
4. ‚úÖ **Peek**: Returns top without removing - O(1)
5. ‚úÖ **Empty Check**: Checks length - O(1)

**Time Complexity**: All operations are O(1) ‚úÖ

### üîß Complete Refactor

```go
// stack.go
package main

import (
    "errors"
    "fmt"
)

var (
    ErrStackEmpty = errors.New("stack is empty")
)

// Stack represents a LIFO (Last-In-First-Out) data structure
type Stack struct {
    data []int
}

// NewStack creates a new stack
func NewStack() *Stack {
    return &Stack{
        data: make([]int, 0),
    }
}

// Push adds an element to the top of the stack
func (s *Stack) Push(value int) {
    s.data = append(s.data, value)
}

// Pop removes and returns the top element
func (s *Stack) Pop() (int, error) {
    if s.IsEmpty() {
        return 0, ErrStackEmpty
    }
    value := s.data[len(s.data)-1]
    s.data = s.data[:len(s.data)-1]
    return value, nil
}

// Peek returns the top element without removing it
func (s *Stack) Peek() (int, error) {
    if s.IsEmpty() {
        return 0, ErrStackEmpty
    }
    return s.data[len(s.data)-1], nil
}

// IsEmpty checks if the stack is empty
func (s *Stack) IsEmpty() bool {
    return len(s.data) == 0
}

// Size returns the number of elements in the stack
func (s *Stack) Size() int {
    return len(s.data)
}

// Display shows all stack elements
func (s *Stack) Display() {
    if s.IsEmpty() {
        fmt.Println("Stack is empty")
        return
    }

    fmt.Println("Stack (top to bottom):")
    for i := len(s.data) - 1; i >= 0; i-- {
        if i == len(s.data)-1 {
            fmt.Printf("  [TOP] -> %d\n", s.data[i])
        } else {
            fmt.Printf("          %d\n", s.data[i])
        }
    }
}

// InteractiveMenu runs the CLI interface
func (s *Stack) InteractiveMenu() {
    const (
        exit = iota
        push
        pop
        peek
        display
    )

    for {
        fmt.Println("\n=== Stack Operations ===")
        fmt.Println("1. Push")
        fmt.Println("2. Pop")
        fmt.Println("3. Peek")
        fmt.Println("4. Display")
        fmt.Println("0. Exit")
        fmt.Print("Choice: ")

        var choice int
        if _, err := fmt.Scan(&choice); err != nil {
            fmt.Println("Invalid input!")
            continue
        }

        switch choice {
        case exit:
            fmt.Println("Exiting stack demo...")
            return

        case push:
            var value int
            fmt.Print("Enter value to push: ")
            if _, err := fmt.Scan(&value); err != nil {
                fmt.Println("Invalid input!")
                continue
            }
            s.Push(value)
            fmt.Printf("‚úì Pushed %d onto stack\n", value)

        case pop:
            if value, err := s.Pop(); err != nil {
                fmt.Println("‚ùå", err)
            } else {
                fmt.Printf("‚úì Popped %d from stack\n", value)
            }

        case peek:
            if value, err := s.Peek(); err != nil {
                fmt.Println("‚ùå", err)
            } else {
                fmt.Printf("Top of stack: %d\n", value)
            }

        case display:
            s.Display()

        default:
            fmt.Println("Invalid choice! Please choose 0-4")
        }
    }
}
```

```go
// main.go
package main

func main() {
    stack := NewStack()
    stack.InteractiveMenu()
}
```

### üß™ Unit Tests

```go
// stack_test.go
package main

import "testing"

func TestStack(t *testing.T) {
    s := NewStack()

    // Test empty stack
    if !s.IsEmpty() {
        t.Error("New stack should be empty")
    }

    // Test pop on empty stack
    if _, err := s.Pop(); err != ErrStackEmpty {
        t.Error("Should return ErrStackEmpty")
    }

    // Test push
    s.Push(10)
    s.Push(20)
    s.Push(30)

    if s.Size() != 3 {
        t.Errorf("Expected size 3, got %d", s.Size())
    }

    // Test peek
    if val, _ := s.Peek(); val != 30 {
        t.Errorf("Expected 30, got %d", val)
    }

    // Peek shouldn't remove element
    if s.Size() != 3 {
        t.Error("Peek should not remove element")
    }

    // Test LIFO order
    expected := []int{30, 20, 10}
    for _, exp := range expected {
        if val, _ := s.Pop(); val != exp {
            t.Errorf("Expected %d, got %d", exp, val)
        }
    }

    // Should be empty now
    if !s.IsEmpty() {
        t.Error("Stack should be empty")
    }
}

func TestStackPeek(t *testing.T) {
    s := NewStack()
    s.Push(42)

    // Peek multiple times
    for i := 0; i < 3; i++ {
        if val, _ := s.Peek(); val != 42 {
            t.Errorf("Peek %d: expected 42, got %d", i, val)
        }
    }

    // Should still have the element
    if s.Size() != 1 {
        t.Error("Peek should not modify stack size")
    }
}
```

---

## Rating Breakdown

| Category              | Rating | Comments                    |
| --------------------- | ------ | --------------------------- |
| Algorithm Correctness | 9/10   | LIFO behavior is correct    |
| Code Quality          | 6/10   | Works but has naming issues |
| Error Handling        | 6/10   | Bool pattern is confusing   |
| Implementation        | 8/10   | Clean and simple            |

**Overall: 7/10**

---

## Key Action Items

1. üö® **Rename folder**: `skack/` ‚Üí `stack/`
2. ‚ö†Ô∏è Fix spelling: "poped" ‚Üí "popped"
3. ‚ö†Ô∏è Add newlines to output statements
4. ‚ö†Ô∏è Use `error` return type instead of `bool`
5. ‚ö†Ô∏è Remove debug comments
6. ‚ö†Ô∏è Add input validation
7. ‚úÖ Consider struct-based design
8. ‚úÖ Add unit tests

**Good solid implementation! Just needs polish and bug fixes.**
