# Code Review: 0.0004/prorityQueue/main.go

## Overall Assessment

**File Purpose**: Alternative Priority Queue implementation  
**Rating**: 5/10  
**Status**: Incomplete implementation with bugs

---

## üö® **CRITICAL ISSUES**

### Issue #1: Spelling - Again!

```
0.0004/prorityQueue/  ‚ùå
0.0004/priorityQueue/  ‚úÖ
```

The folder name has the same typo as before: "prority" ‚Üí "priority"

### Issue #2: **Incomplete Implementation**

This file appears to be an experimental/incomplete version of your priority queue. It has several bugs and incomplete logic.

---

## Detailed Review

### ‚ö†Ô∏è **BUGS**

#### Bug #1: Front Array Logic is Broken

```go
var (
    queue [5][]int
    front [5]int = [5]int{-1, -1, -1, -1, -1}  // What is this tracking?
)
```

**Problem**: You're tracking a `front` index for each priority level, but your queue uses slices (dynamic arrays), not fixed-position arrays. The `front` array doesn't make sense with this design.

**Explanation**:

- In your `0.0002/queue/prorityQueue.go`, you correctly use slices without tracking front
- In THIS file, you're mixing circular queue logic (front index) with linear queue logic (slices)
- **These two approaches don't work together!**

#### Bug #2: Dequeue Logic is Wrong

```go
func Dequeue() (int, bool) {
    if isEmpty() {
        fmt.Println("Queue is Empty !!!")
        return 0, true
    }

    for i := range 5 {
        if front[i] > -1 {  // Check if this priority has items
            if front[i] == 0 {
                front[i] = -1
                return queue[i][0], false  // ‚ö†Ô∏è Doesn't remove from slice!
            } else {
                front[i] = front[i] + 1
                return queue[i][front[i-1]], false  // ‚ö†Ô∏è Wrong index!
            }
        }
    }

    return 1, true  // ‚ö†Ô∏è Why return 1 instead of 0?
}
```

**Multiple Issues**:

1. **Doesn't remove from slice**: Returns `queue[i][0]` but never does `queue[i] = queue[i][1:]`
2. **Wrong index**: `front[i-1]` should be `front[i]` (typo!)
3. **Logic confusion**: Mixing front pointer with slice indexing
4. **Inconsistent return**: Returns `1` instead of `0` on error

**What happens**:

- You dequeue the same element repeatedly
- The queue never actually shrinks
- Eventually panic with index out of range

#### Bug #3: isEmpty() is Wrong

```go
func isEmpty() bool {
    check := 0
    for i := range queue {
        check += len(queue[i])
    }
    if check < 0 {  // ‚ö†Ô∏è Length can NEVER be negative!
        return true
    }
    return false
}
```

**Issue**: `check < 0` is impossible since lengths are always ‚â• 0. This function ALWAYS returns `false`!

**Should be**:

```go
func isEmpty() bool {
    for _, q := range queue {
        if len(q) > 0 {
            return false
        }
    }
    return true
}
```

#### Bug #4: Peek Logic Also Broken

```go
func peekQueue() {
    // ...
    for i := range 5 {
        if front[i] > -1 {
            fmt.Printf("---->\t%d\t<--- will be cumming next with prority:\t%d",
                queue[i][front[i]], front[i])
            // ‚ö†Ô∏è Two issues:
            // 1. "cumming" typo again
            // 2. If front[i] is not 0, this might panic or show wrong element
            return
        }
    }
}
```

#### Bug #5: Enqueue Front Tracking Makes No Sense

```go
func Enqueue() (int, int8) {
    // ...
    queue[prority] = append(queue[prority], value)

    if front[prority] == -1 {
        front[prority] = 0  // OK, mark as having elements
    }
    // But then you never increment front! And you don't need to track it anyway.
    return value, prority
}
```

**Issue**: Setting `front[prority] = 0` makes sense as a flag ("this priority has elements"), but then you try to use it as an index in Dequeue, which doesn't work with slices.

### ü§î What Were You Trying to Do?

It looks like you tried to combine two approaches:

1. **Your working 0.0002 version**: Array of slices, no front tracking needed
2. **Circular queue logic**: Tracking front indices

**These don't mix!** Pick one:

- **Slices**: No front tracking, just use `[0]` and `[1:]`
- **Fixed arrays**: Track front/rear like your circular queue

### üìö Conceptual Confusion

| Approach                   | Storage           | Front Tracking    | Dequeue                                |
| -------------------------- | ----------------- | ----------------- | -------------------------------------- |
| **Your 0.0002 version** ‚úÖ | `[5][]int` slices | None needed       | `queue[p][0]; queue[p] = queue[p][1:]` |
| **This version** ‚ùå        | `[5][]int` slices | `[5]int` front    | Confused mix of both!                  |
| **Circular Queue** ‚úÖ      | `[5]int` array    | `front, rear int` | `arr[front]; front = (front+1) % size` |

### üîß How to Fix

**Option 1**: Go back to your 0.0002 version (it works!)

**Option 2**: If you want to learn front tracking, use fixed-size arrays:

```go
const (
    MaxPriorities = 5
    MaxQueueSize = 10
)

var (
    queues [MaxPriorities][MaxQueueSize]int
    fronts [MaxPriorities]int
    rears  [MaxPriorities]int
    sizes  [MaxPriorities]int
)

func Enqueue(value int, priority int) error {
    if sizes[priority] >= MaxQueueSize {
        return errors.New("queue full")
    }
    queues[priority][rears[priority]] = value
    rears[priority] = (rears[priority] + 1) % MaxQueueSize
    sizes[priority]++
    return nil
}

func Dequeue() (int, int, error) {
    for p := range MaxPriorities {
        if sizes[p] > 0 {
            value := queues[p][fronts[p]]
            fronts[p] = (fronts[p] + 1) % MaxQueueSize
            sizes[p]--
            return value, p, nil
        }
    }
    return 0, 0, errors.New("empty")
}
```

But honestly, **your 0.0002 version is better for this use case!**

### üìä Comparison

| Version                          | Status     | Rating | Notes                        |
| -------------------------------- | ---------- | ------ | ---------------------------- |
| **0.0002/queue/prorityQueue.go** | ‚úÖ Working | 7/10   | Good design, works correctly |
| **0.0004/prorityQueue/main.go**  | ‚ùå Broken  | 5/10   | Logic errors, incomplete     |

---

## Rating Breakdown

| Category      | Rating | Comments                                          |
| ------------- | ------ | ------------------------------------------------- |
| Correctness   | 3/10   | Multiple bugs, doesn't work properly              |
| Code Quality  | 5/10   | Some structure but confused logic                 |
| Understanding | 6/10   | Attempting advanced concept but mixing approaches |
| Completeness  | 4/10   | Incomplete, has commented debug output            |

**Overall: 5/10**

---

## Recommendations

### Short Term

1. üö® **Use your 0.0002 version** - it works!
2. üö® Delete this version or mark it as "experimental/broken"
3. üö® Fix spelling: "prority" ‚Üí "priority"

### Long Term

1. Learn **when** to use front tracking (circular queues with fixed arrays)
2. Learn **when** to use slices (dynamic queues)
3. **Don't mix** the two approaches
4. Write **unit tests** to catch these bugs early:
   ```go
   func TestDequeue(t *testing.T) {
       Enqueue(10, 0)
       Enqueue(20, 0)
       val1, _, _ := Dequeue()
       val2, _, _ := Dequeue()
       if val1 == val2 {
           t.Error("Dequeued same value twice!")  // Would catch your bug!
       }
   }
   ```

### Learning Resources

- Study difference between arrays and slices
- Review your circular queue implementation (it's correct!)
- Review your 0.0002 priority queue (also correct!)
- Understand when to use each approach

---

## What You Did Right

1. ‚úÖ Trying different approaches (experimentation is good!)
2. ‚úÖ Using constants and structured code
3. ‚úÖ Thinking about data structure design

## What Needs Work

1. ‚ùå Testing your code before committing
2. ‚ùå Understanding when to use different data structures
3. ‚ùå Completing implementations before moving on
4. ‚ùå Fixing the same typos repeatedly ("prority")

---

**Verdict**: This version needs significant work. Stick with your 0.0002 version, which is much better! Consider this file a learning experience about what NOT to mix together.
