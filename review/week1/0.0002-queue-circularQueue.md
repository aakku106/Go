# Code Review: 0.0002/queue/circularQueue.go

## Overall Assessment

**File Purpose**: Circular Queue implementation  
**Rating**: 8.5/10  
**Status**: Excellent implementation with proper circular logic!

---

## Detailed Review

### ‚úÖ Strengths

1. **Correct Circular Logic**: Proper use of modulo operator `(rear + 1) % len(...)`
2. **Front/Rear Tracking**: Good use of indices for circular behavior
3. **Full/Empty Detection**: Correctly handles full queue detection
4. **Edge Cases**: Handles reset when `front == rear` after dequeue
5. **Algorithm Understanding**: You clearly understand circular queues!

### ‚ö†Ô∏è Issues & Improvements

#### 1. **Global Variables**

```go
var frontOFcirularQueue, rearOfCircularQueue int = -1, -1
```

**Issues**:

- Typo: "cirular" ‚Üí "circular"
- Typo: "OF" ‚Üí "Of" (camelCase convention)
- Global state makes code harder to test and reuse

**Better**:

```go
var (
    frontOfCircularQueue int = -1
    rearOfCircularQueue  int = -1
)

// Or better: use a struct
type CircularQueue struct {
    data []int
    front int
    rear int
    size int
}
```

#### 2. **Confusing Return Values**

```go
func EnqueueInCircularQueue() (int, bool) {
    if !isCircularQueueFull() {
        // ... success
        return value, false  // false = not full (success)
    }
    return 0, true  // true = was full (failure)
}
```

**Problem**: `true` means failure, `false` means success. This is backwards!

**Go Convention**:

```go
// Option 1: Use 'ok' pattern (true = success)
func EnqueueInCircularQueue() (int, bool) {
    if isCircularQueueFull() {
        return 0, false  // false = failed
    }
    // ... enqueue
    return value, true  // true = success
}

// Option 2: Use error (nil = success)
func EnqueueInCircularQueue() (int, error) {
    if isCircularQueueFull() {
        return 0, errors.New("queue is full")
    }
    // ... enqueue
    return value, nil
}
```

#### 3. **Bug in Enqueue Logic**

```go
func EnqueueInCircularQueue() (int, bool) {
    if !isCircularQueueFull() {
        var value int
        fmt.Println("Give data to enqueue in circular Queue")
        fmt.Scan(&value)
        rearOfCircularQueue = (rearOfCircularQueue + 1) % len(circularQueueStoragePlace)
        circularQueueStoragePlace[rearOfCircularQueue] = value
        if frontOFcirularQueue < 0 {  // ‚ö†Ô∏è This check is AFTER incrementing rear!
            frontOFcirularQueue, rearOfCircularQueue = 0, 0
        }
        return value, false
    }
    // ...
}
```

**Problem**: You increment `rear` before checking if queue is empty. This works but is logically backwards.

**Better Flow**:

```go
func EnqueueInCircularQueue() (int, error) {
    if isCircularQueueFull() {
        return 0, errors.New("queue is full")
    }

    var value int
    fmt.Print("Enter value to enqueue: ")
    fmt.Scan(&value)

    // First time enqueueing
    if frontOfCircularQueue == -1 {
        frontOfCircularQueue = 0
        rearOfCircularQueue = 0
    } else {
        rearOfCircularQueue = (rearOfCircularQueue + 1) % len(circularQueueStoragePlace)
    }

    circularQueueStoragePlace[rearOfCircularQueue] = value
    return value, nil
}
```

#### 4. **Commented Debug Code**

```go
//	fmt.Printf("\n\n\tqueue:\t%v\tfront:\t%d\trear\t%d\tlen:%d\tcap:%d\n", ...)
```

**Issue**: Leaving commented debug code makes code messy

**Better Options**:

1. Remove it
2. Use a debug flag:

   ```go
   const debug = false

   if debug {
       fmt.Printf("Queue state: front=%d, rear=%d\n", front, rear)
   }
   ```

3. Use proper logging:
   ```go
   log.Printf("Queue state: front=%d, rear=%d\n", front, rear)
   ```

#### 5. **Inconsistent Formatting**

```go
if frontOFcirularQueue < 0 {
    return true
}
return false
```

**Can be simplified**:

```go
return frontOfCircularQueue < 0
```

Same for `isCircularQueueFull()`:

```go
func isCircularQueueFull() bool {
    return (rearOfCircularQueue + 1) % len(circularQueueStoragePlace) == frontOfCircularQueue
}
```

### üìö Circular Queue Concepts (You Got Right!)

1. ‚úÖ **Circular Wrap**: Using `(index + 1) % size`
2. ‚úÖ **Full Condition**: `(rear + 1) % size == front`
3. ‚úÖ **Empty Condition**: `front == -1`
4. ‚úÖ **Reset Logic**: Setting `front = rear = -1` when emptied
5. ‚úÖ **Efficient Space Usage**: Reusing array space

### üéØ Complete Refactored Example

```go
package queue

import (
    "errors"
    "fmt"
)

var (
    ErrQueueEmpty = errors.New("queue is empty")
    ErrQueueFull  = errors.New("queue is full")
)

// CircularQueue implements a circular queue with fixed size
type CircularQueue struct {
    data  []int
    front int
    rear  int
    size  int
}

// NewCircularQueue creates a circular queue with given capacity
func NewCircularQueue(capacity int) *CircularQueue {
    return &CircularQueue{
        data:  make([]int, capacity),
        front: -1,
        rear:  -1,
        size:  capacity,
    }
}

// Enqueue adds an element to the queue
func (q *CircularQueue) Enqueue(value int) error {
    if q.IsFull() {
        return ErrQueueFull
    }

    // First element
    if q.front == -1 {
        q.front = 0
        q.rear = 0
    } else {
        q.rear = (q.rear + 1) % q.size
    }

    q.data[q.rear] = value
    return nil
}

// Dequeue removes and returns the front element
func (q *CircularQueue) Dequeue() (int, error) {
    if q.IsEmpty() {
        return 0, ErrQueueEmpty
    }

    value := q.data[q.front]

    // Queue becomes empty
    if q.front == q.rear {
        q.front = -1
        q.rear = -1
    } else {
        q.front = (q.front + 1) % q.size
    }

    return value, nil
}

// Peek returns the front element without removing it
func (q *CircularQueue) Peek() (int, error) {
    if q.IsEmpty() {
        return 0, ErrQueueEmpty
    }
    return q.data[q.front], nil
}

// IsEmpty checks if queue is empty
func (q *CircularQueue) IsEmpty() bool {
    return q.front == -1
}

// IsFull checks if queue is full
func (q *CircularQueue) IsFull() bool {
    return (q.rear+1)%q.size == q.front
}

// Count returns number of elements in queue
func (q *CircularQueue) Count() int {
    if q.IsEmpty() {
        return 0
    }
    if q.rear >= q.front {
        return q.rear - q.front + 1
    }
    return q.size - q.front + q.rear + 1
}

// Display shows queue contents
func (q *CircularQueue) Display() {
    if q.IsEmpty() {
        fmt.Println("Queue is empty")
        return
    }

    fmt.Print("Front -> ")
    i := q.front
    for {
        fmt.Print(q.data[i])
        if i == q.rear {
            break
        }
        fmt.Print(" <- ")
        i = (i + 1) % q.size
    }
    fmt.Println(" <- Rear")
    fmt.Printf("(Front index: %d, Rear index: %d, Count: %d/%d)\n",
        q.front, q.rear, q.Count(), q.size)
}

// InteractiveMenu runs CLI interface
func (q *CircularQueue) InteractiveMenu() {
    for {
        fmt.Println("\n=== Circular Queue ===")
        fmt.Println("1. Enqueue")
        fmt.Println("2. Dequeue")
        fmt.Println("3. Peek")
        fmt.Println("4. Display")
        fmt.Println("0. Back")
        fmt.Print("Choice: ")

        var choice int
        fmt.Scan(&choice)

        switch choice {
        case 0:
            return
        case 1:
            var value int
            fmt.Print("Enter value: ")
            fmt.Scan(&value)
            if err := q.Enqueue(value); err != nil {
                fmt.Println("‚ùå", err)
            } else {
                fmt.Printf("‚úì Enqueued %d\n", value)
            }
        case 2:
            if value, err := q.Dequeue(); err != nil {
                fmt.Println("‚ùå", err)
            } else {
                fmt.Printf("‚úì Dequeued %d\n", value)
            }
        case 3:
            if value, err := q.Peek(); err != nil {
                fmt.Println("‚ùå", err)
            } else {
                fmt.Printf("Next value: %d\n", value)
            }
        case 4:
            q.Display()
        default:
            fmt.Println("Invalid choice")
        }
    }
}
```

### üß™ Unit Tests

```go
// circularQueue_test.go
func TestCircularQueue(t *testing.T) {
    q := NewCircularQueue(3)

    // Test empty queue
    if !q.IsEmpty() {
        t.Error("New queue should be empty")
    }

    // Test enqueue
    q.Enqueue(10)
    q.Enqueue(20)
    q.Enqueue(30)

    // Test full
    if !q.IsFull() {
        t.Error("Queue should be full")
    }

    // Can't enqueue when full
    if err := q.Enqueue(40); err != ErrQueueFull {
        t.Error("Should return ErrQueueFull")
    }

    // Test dequeue
    if val, _ := q.Dequeue(); val != 10 {
        t.Errorf("Expected 10, got %d", val)
    }

    // Now we can enqueue again (circular!)
    q.Enqueue(40)

    // Test circular behavior
    expected := []int{20, 30, 40}
    for _, exp := range expected {
        if val, _ := q.Dequeue(); val != exp {
            t.Errorf("Expected %d, got %d", exp, val)
        }
    }

    // Should be empty now
    if !q.IsEmpty() {
        t.Error("Queue should be empty")
    }
}
```

---

## Rating Breakdown

| Category              | Rating | Comments                               |
| --------------------- | ------ | -------------------------------------- |
| Algorithm Correctness | 10/10  | Perfect circular logic!                |
| Code Quality          | 7/10   | Works great, naming issues             |
| Understanding         | 9/10   | You clearly understand circular queues |
| Error Handling        | 7/10   | Good but backwards boolean convention  |
| Memory Efficiency     | 10/10  | Excellent space reuse                  |

**Overall: 8.5/10**

---

## Key Takeaways

1. ‚úÖ **You nailed circular queues!** The algorithm is correct
2. ‚ö†Ô∏è Fix naming: "cirular" ‚Üí "circular"
3. ‚ö†Ô∏è Use Go error conventions: errors or `ok` booleans
4. ‚ö†Ô∏è Consider struct-based design for better encapsulation
5. ‚úÖ Your modulo arithmetic is perfect!

**This is your best implementation so far! Great work on understanding circular queues.**
